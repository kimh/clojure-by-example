
<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <title>Clojure by Example</title>

    <style>
      .highlight table td { padding: 5px; }
.highlight table pre { margin: 0; }
.highlight .gh {
  color: #999999;
}
.highlight .sr {
  color: #f6aa11;
}
.highlight .go {
  color: #888888;
}
.highlight .gp {
  color: #555555;
}
.highlight .gs {
}
.highlight .gu {
  color: #aaaaaa;
}
.highlight .nb {
  color: #f6aa11;
}
.highlight .cm {
  color: #75715e;
}
.highlight .cp {
  color: #75715e;
}
.highlight .c1 {
  color: #75715e;
}
.highlight .cs {
  color: #75715e;
}
.highlight .c, .highlight .cd {
  color: #75715e;
}
.highlight .err {
  color: #960050;
}
.highlight .gr {
  color: #960050;
}
.highlight .gt {
  color: #960050;
}
.highlight .gd {
  color: #49483e;
}
.highlight .gi {
  color: #49483e;
}
.highlight .ge {
  color: #49483e;
}
.highlight .kc {
  color: #66d9ef;
}
.highlight .kd {
  color: #66d9ef;
}
.highlight .kr {
  color: #66d9ef;
}
.highlight .no {
  color: #66d9ef;
}
.highlight .kt {
  color: #66d9ef;
}
.highlight .mf {
  color: #ae81ff;
}
.highlight .mh {
  color: #ae81ff;
}
.highlight .il {
  color: #ae81ff;
}
.highlight .mi {
  color: #ae81ff;
}
.highlight .mo {
  color: #ae81ff;
}
.highlight .m, .highlight .mb, .highlight .mx {
  color: #ae81ff;
}
.highlight .sc {
  color: #ae81ff;
}
.highlight .se {
  color: #ae81ff;
}
.highlight .ss {
  color: #ae81ff;
}
.highlight .sd {
  color: #e6db74;
}
.highlight .s2 {
  color: #e6db74;
}
.highlight .sb {
  color: #e6db74;
}
.highlight .sh {
  color: #e6db74;
}
.highlight .si {
  color: #e6db74;
}
.highlight .sx {
  color: #e6db74;
}
.highlight .s1 {
  color: #e6db74;
}
.highlight .s {
  color: #e6db74;
}
.highlight .na {
  color: #a6e22e;
}
.highlight .nc {
  color: #a6e22e;
}
.highlight .nd {
  color: #a6e22e;
}
.highlight .ne {
  color: #a6e22e;
}
.highlight .nf {
  color: #a6e22e;
}
.highlight .vc {
  color: #ffffff;
}
.highlight .nn {
  color: #ffffff;
}
.highlight .nl {
  color: #ffffff;
}
.highlight .ni {
  color: #ffffff;
}
.highlight .bp {
  color: #ffffff;
}
.highlight .vg {
  color: #ffffff;
}
.highlight .vi {
  color: #ffffff;
}
.highlight .nv {
  color: #ffffff;
}
.highlight .w {
  color: #ffffff;
}
.highlight {
  color: #ffffff;
}
.highlight .n, .highlight .py, .highlight .nx {
  color: #ffffff;
}
.highlight .ow {
  color: #f92672;
}
.highlight .nt {
  color: #f92672;
}
.highlight .k, .highlight .kv {
  color: #f92672;
}
.highlight .kn {
  color: #f92672;
}
.highlight .kp {
  color: #f92672;
}
.highlight .o {
  color: #f92672;
}
    </style>
    <link href="stylesheets/screen.css" rel="stylesheet" media="screen" />
    <link href="stylesheets/print.css" rel="stylesheet" media="print" />
      <script src="javascripts/all.js"></script>
  </head>

  <body class="index" data-languages="[]">
    <a href="#" id="nav-button">
      <span>
        NAV
        <img src="images/navbar.png" alt="Navbar" />
      </span>
    </a>
    <div class="toc-wrapper">
      <div style="margin-bottom : 25px">
        <font size="5" color=#60b325>Clojure</font><font size="5" color=#fff> By</font><font size="5" color=#5881d8> Example</font>
      </div>
        <div class="search">
          <input type="text" class="search" id="input-search" placeholder="Search">
        </div>
        <ul class="search-results"></ul>
      <div id="toc" class="toc-list-h1">
          <li>
            <a href="#about" class="toc-h1 toc-link" data-title="About">About</a>
          </li>
          <li>
            <a href="#hello-world" class="toc-h1 toc-link" data-title="Hello, world!">Hello, world!</a>
          </li>
          <li>
            <a href="#bindings" class="toc-h1 toc-link" data-title="Bindings">Bindings</a>
              <ul class="toc-list-h2">
                  <li>
                    <a href="#symbol" class="toc-h2 toc-link" data-title="Bindings">Symbol</a>
                  </li>
                  <li>
                    <a href="#let" class="toc-h2 toc-link" data-title="Bindings">Let</a>
                  </li>
                  <li>
                    <a href="#scope" class="toc-h2 toc-link" data-title="Bindings">Scope</a>
                  </li>
                  <li>
                    <a href="#def" class="toc-h2 toc-link" data-title="Bindings">Def</a>
                  </li>
              </ul>
          </li>
          <li>
            <a href="#functions" class="toc-h1 toc-link" data-title="Functions">Functions</a>
              <ul class="toc-list-h2">
                  <li>
                    <a href="#defn" class="toc-h2 toc-link" data-title="Functions">Defn</a>
                  </li>
                  <li>
                    <a href="#anonymous-function" class="toc-h2 toc-link" data-title="Functions">Anonymous Function</a>
                  </li>
                  <li>
                    <a href="#closure" class="toc-h2 toc-link" data-title="Functions">Closure</a>
                  </li>
              </ul>
          </li>
          <li>
            <a href="#namespaces" class="toc-h1 toc-link" data-title="Namespaces">Namespaces</a>
              <ul class="toc-list-h2">
                  <li>
                    <a href="#create-ns" class="toc-h2 toc-link" data-title="Namespaces">Create-ns</a>
                  </li>
                  <li>
                    <a href="#in-ns" class="toc-h2 toc-link" data-title="Namespaces">In-ns</a>
                  </li>
                  <li>
                    <a href="#require" class="toc-h2 toc-link" data-title="Namespaces">Require</a>
                  </li>
                  <li>
                    <a href="#refer" class="toc-h2 toc-link" data-title="Namespaces">Refer</a>
                  </li>
                  <li>
                    <a href="#use" class="toc-h2 toc-link" data-title="Namespaces">Use</a>
                  </li>
                  <li>
                    <a href="#import" class="toc-h2 toc-link" data-title="Namespaces">Import</a>
                  </li>
                  <li>
                    <a href="#ns" class="toc-h2 toc-link" data-title="Namespaces">Ns</a>
                  </li>
              </ul>
          </li>
          <li>
            <a href="#control-flow" class="toc-h1 toc-link" data-title="Control Flow">Control Flow</a>
              <ul class="toc-list-h2">
                  <li>
                    <a href="#if" class="toc-h2 toc-link" data-title="Control Flow">If</a>
                  </li>
                  <li>
                    <a href="#if-let" class="toc-h2 toc-link" data-title="Control Flow">If-Let</a>
                  </li>
                  <li>
                    <a href="#when" class="toc-h2 toc-link" data-title="Control Flow">When</a>
                  </li>
                  <li>
                    <a href="#when-let" class="toc-h2 toc-link" data-title="Control Flow">When-Let</a>
                  </li>
                  <li>
                    <a href="#case" class="toc-h2 toc-link" data-title="Control Flow">Case</a>
                  </li>
                  <li>
                    <a href="#cond" class="toc-h2 toc-link" data-title="Control Flow">Cond</a>
                  </li>
                  <li>
                    <a href="#condp" class="toc-h2 toc-link" data-title="Control Flow">Condp</a>
                  </li>
              </ul>
          </li>
          <li>
            <a href="#boolean" class="toc-h1 toc-link" data-title="Boolean">Boolean</a>
          </li>
          <li>
            <a href="#strings" class="toc-h1 toc-link" data-title="Strings">Strings</a>
              <ul class="toc-list-h2">
                  <li>
                    <a href="#literal" class="toc-h2 toc-link" data-title="Strings">Literal</a>
                  </li>
                  <li>
                    <a href="#str" class="toc-h2 toc-link" data-title="Strings">Str</a>
                  </li>
                  <li>
                    <a href="#format" class="toc-h2 toc-link" data-title="Strings">Format</a>
                  </li>
              </ul>
          </li>
          <li>
            <a href="#integers" class="toc-h1 toc-link" data-title="Integers">Integers</a>
              <ul class="toc-list-h2">
                  <li>
                    <a href="#addition" class="toc-h2 toc-link" data-title="Integers">Addition</a>
                  </li>
                  <li>
                    <a href="#subtraction" class="toc-h2 toc-link" data-title="Integers">Subtraction</a>
                  </li>
                  <li>
                    <a href="#multiplication" class="toc-h2 toc-link" data-title="Integers">Multiplication</a>
                  </li>
                  <li>
                    <a href="#division" class="toc-h2 toc-link" data-title="Integers">Division</a>
                  </li>
                  <li>
                    <a href="#modulo" class="toc-h2 toc-link" data-title="Integers">Modulo</a>
                  </li>
                  <li>
                    <a href="#max" class="toc-h2 toc-link" data-title="Integers">Max</a>
                  </li>
                  <li>
                    <a href="#min" class="toc-h2 toc-link" data-title="Integers">Min</a>
                  </li>
                  <li>
                    <a href="#power" class="toc-h2 toc-link" data-title="Integers">Power</a>
                  </li>
                  <li>
                    <a href="#bigint" class="toc-h2 toc-link" data-title="Integers">Bigint</a>
                  </li>
              </ul>
          </li>
          <li>
            <a href="#lists" class="toc-h1 toc-link" data-title="Lists">Lists</a>
              <ul class="toc-list-h2">
                  <li>
                    <a href="#literal-2" class="toc-h2 toc-link" data-title="Lists">Literal</a>
                  </li>
                  <li>
                    <a href="#conj" class="toc-h2 toc-link" data-title="Lists">Conj</a>
                  </li>
                  <li>
                    <a href="#how-can-i-remove-elements" class="toc-h2 toc-link" data-title="Lists">How can I remove elements?</a>
                  </li>
                  <li>
                    <a href="#nth" class="toc-h2 toc-link" data-title="Lists">Nth</a>
                  </li>
                  <li>
                    <a href="#count" class="toc-h2 toc-link" data-title="Lists">Count</a>
                  </li>
              </ul>
          </li>
          <li>
            <a href="#vectors" class="toc-h1 toc-link" data-title="Vectors">Vectors</a>
              <ul class="toc-list-h2">
                  <li>
                    <a href="#literal-3" class="toc-h2 toc-link" data-title="Vectors">Literal</a>
                  </li>
                  <li>
                    <a href="#conj-2" class="toc-h2 toc-link" data-title="Vectors">Conj</a>
                  </li>
                  <li>
                    <a href="#how-can-i-remove-elements-2" class="toc-h2 toc-link" data-title="Vectors">How can I remove elements?</a>
                  </li>
                  <li>
                    <a href="#nth-2" class="toc-h2 toc-link" data-title="Vectors">Nth</a>
                  </li>
                  <li>
                    <a href="#indexof" class="toc-h2 toc-link" data-title="Vectors">.indexOf</a>
                  </li>
              </ul>
          </li>
          <li>
            <a href="#sets" class="toc-h1 toc-link" data-title="Sets">Sets</a>
              <ul class="toc-list-h2">
                  <li>
                    <a href="#literal-4" class="toc-h2 toc-link" data-title="Sets">Literal</a>
                  </li>
                  <li>
                    <a href="#conj-3" class="toc-h2 toc-link" data-title="Sets">Conj</a>
                  </li>
                  <li>
                    <a href="#disj" class="toc-h2 toc-link" data-title="Sets">Disj</a>
                  </li>
                  <li>
                    <a href="#sort" class="toc-h2 toc-link" data-title="Sets">Sort</a>
                  </li>
                  <li>
                    <a href="#contains" class="toc-h2 toc-link" data-title="Sets">Contains?</a>
                  </li>
                  <li>
                    <a href="#subset" class="toc-h2 toc-link" data-title="Sets">Subset?</a>
                  </li>
                  <li>
                    <a href="#superset" class="toc-h2 toc-link" data-title="Sets">Superset?</a>
                  </li>
              </ul>
          </li>
          <li>
            <a href="#maps" class="toc-h1 toc-link" data-title="Maps">Maps</a>
              <ul class="toc-list-h2">
                  <li>
                    <a href="#literal-5" class="toc-h2 toc-link" data-title="Maps">Literal</a>
                  </li>
                  <li>
                    <a href="#get" class="toc-h2 toc-link" data-title="Maps">Get</a>
                  </li>
                  <li>
                    <a href="#assoc" class="toc-h2 toc-link" data-title="Maps">Assoc</a>
                  </li>
                  <li>
                    <a href="#merge" class="toc-h2 toc-link" data-title="Maps">Merge</a>
                  </li>
                  <li>
                    <a href="#keys" class="toc-h2 toc-link" data-title="Maps">Keys</a>
                  </li>
                  <li>
                    <a href="#vals" class="toc-h2 toc-link" data-title="Maps">Vals</a>
                  </li>
              </ul>
          </li>
          <li>
            <a href="#sequences" class="toc-h1 toc-link" data-title="Sequences">Sequences</a>
              <ul class="toc-list-h2">
                  <li>
                    <a href="#seq" class="toc-h2 toc-link" data-title="Sequences">Seq</a>
                  </li>
                  <li>
                    <a href="#first" class="toc-h2 toc-link" data-title="Sequences">First</a>
                  </li>
                  <li>
                    <a href="#rest" class="toc-h2 toc-link" data-title="Sequences">Rest</a>
                  </li>
                  <li>
                    <a href="#cons" class="toc-h2 toc-link" data-title="Sequences">Cons</a>
                  </li>
                  <li>
                    <a href="#concat" class="toc-h2 toc-link" data-title="Sequences">Concat</a>
                  </li>
                  <li>
                    <a href="#map" class="toc-h2 toc-link" data-title="Sequences">Map</a>
                  </li>
                  <li>
                    <a href="#reduce" class="toc-h2 toc-link" data-title="Sequences">Reduce</a>
                  </li>
                  <li>
                    <a href="#into" class="toc-h2 toc-link" data-title="Sequences">Into</a>
                  </li>
                  <li>
                    <a href="#reverse" class="toc-h2 toc-link" data-title="Sequences">Reverse</a>
                  </li>
                  <li>
                    <a href="#iterate" class="toc-h2 toc-link" data-title="Sequences">Iterate</a>
                  </li>
                  <li>
                    <a href="#range" class="toc-h2 toc-link" data-title="Sequences">Range</a>
                  </li>
                  <li>
                    <a href="#repeatedly" class="toc-h2 toc-link" data-title="Sequences">Repeatedly</a>
                  </li>
                  <li>
                    <a href="#doseq" class="toc-h2 toc-link" data-title="Sequences">Doseq</a>
                  </li>
                  <li>
                    <a href="#take" class="toc-h2 toc-link" data-title="Sequences">Take</a>
                  </li>
                  <li>
                    <a href="#take-while" class="toc-h2 toc-link" data-title="Sequences">Take-While</a>
                  </li>
                  <li>
                    <a href="#drop" class="toc-h2 toc-link" data-title="Sequences">Drop</a>
                  </li>
                  <li>
                    <a href="#drop-while" class="toc-h2 toc-link" data-title="Sequences">Drop-While</a>
                  </li>
                  <li>
                    <a href="#filter" class="toc-h2 toc-link" data-title="Sequences">Filter</a>
                  </li>
                  <li>
                    <a href="#remove" class="toc-h2 toc-link" data-title="Sequences">Remove</a>
                  </li>
                  <li>
                    <a href="#partition-by" class="toc-h2 toc-link" data-title="Sequences">Partition-by</a>
                  </li>
                  <li>
                    <a href="#group-by" class="toc-h2 toc-link" data-title="Sequences">Group-by</a>
                  </li>
                  <li>
                    <a href="#lazy-sequence" class="toc-h2 toc-link" data-title="Sequences">Lazy Sequence</a>
                  </li>
                  <li>
                    <a href="#for" class="toc-h2 toc-link" data-title="Sequences">For</a>
                  </li>
              </ul>
          </li>
          <li>
            <a href="#recursion" class="toc-h1 toc-link" data-title="Recursion">Recursion</a>
              <ul class="toc-list-h2">
                  <li>
                    <a href="#recur" class="toc-h2 toc-link" data-title="Recursion">Recur</a>
                  </li>
                  <li>
                    <a href="#loop" class="toc-h2 toc-link" data-title="Recursion">Loop</a>
                  </li>
              </ul>
          </li>
          <li>
            <a href="#macros" class="toc-h1 toc-link" data-title="Macros">Macros</a>
              <ul class="toc-list-h2">
                  <li>
                    <a href="#defmacro" class="toc-h2 toc-link" data-title="Macros">Defmacro</a>
                  </li>
                  <li>
                    <a href="#macroexpand" class="toc-h2 toc-link" data-title="Macros">Macroexpand</a>
                  </li>
                  <li>
                    <a href="#quotes" class="toc-h2 toc-link" data-title="Macros">Quotes</a>
                  </li>
                  <li>
                    <a href="#syntax-quotes" class="toc-h2 toc-link" data-title="Macros">Syntax-Quotes</a>
                  </li>
                  <li>
                    <a href="#unquotes" class="toc-h2 toc-link" data-title="Macros">Unquotes</a>
                  </li>
                  <li>
                    <a href="#unquote-splice" class="toc-h2 toc-link" data-title="Macros">Unquote-Splice</a>
                  </li>
              </ul>
          </li>
          <li>
            <a href="#threading-macros" class="toc-h1 toc-link" data-title="Threading Macros">Threading Macros</a>
              <ul class="toc-list-h2">
                  <li>
                    <a href="#gt" class="toc-h2 toc-link" data-title="Threading Macros">-&gt;</a>
                  </li>
                  <li>
                    <a href="#gt-gt" class="toc-h2 toc-link" data-title="Threading Macros">-&gt;&gt;</a>
                  </li>
              </ul>
          </li>
          <li>
            <a href="#delays" class="toc-h1 toc-link" data-title="Delays">Delays</a>
              <ul class="toc-list-h2">
                  <li>
                    <a href="#delay" class="toc-h2 toc-link" data-title="Delays">Delay</a>
                  </li>
                  <li>
                    <a href="#force" class="toc-h2 toc-link" data-title="Delays">Force</a>
                  </li>
              </ul>
          </li>
          <li>
            <a href="#futures" class="toc-h1 toc-link" data-title="Futures">Futures</a>
              <ul class="toc-list-h2">
                  <li>
                    <a href="#future" class="toc-h2 toc-link" data-title="Futures">Future</a>
                  </li>
                  <li>
                    <a href="#deref" class="toc-h2 toc-link" data-title="Futures">Deref</a>
                  </li>
                  <li>
                    <a href="#realized" class="toc-h2 toc-link" data-title="Futures">Realized?</a>
                  </li>
              </ul>
          </li>
          <li>
            <a href="#promises" class="toc-h1 toc-link" data-title="Promises">Promises</a>
              <ul class="toc-list-h2">
                  <li>
                    <a href="#promise" class="toc-h2 toc-link" data-title="Promises">Promise</a>
                  </li>
              </ul>
          </li>
          <li>
            <a href="#atoms" class="toc-h1 toc-link" data-title="Atoms">Atoms</a>
              <ul class="toc-list-h2">
                  <li>
                    <a href="#atom" class="toc-h2 toc-link" data-title="Atoms">Atom</a>
                  </li>
                  <li>
                    <a href="#reset" class="toc-h2 toc-link" data-title="Atoms">Reset!</a>
                  </li>
                  <li>
                    <a href="#swap" class="toc-h2 toc-link" data-title="Atoms">Swap!</a>
                  </li>
                  <li>
                    <a href="#thread-safety" class="toc-h2 toc-link" data-title="Atoms">Thread Safety</a>
                  </li>
              </ul>
          </li>
          <li>
            <a href="#refs" class="toc-h1 toc-link" data-title="Refs">Refs</a>
              <ul class="toc-list-h2">
                  <li>
                    <a href="#ref" class="toc-h2 toc-link" data-title="Refs">Ref</a>
                  </li>
                  <li>
                    <a href="#do-sync" class="toc-h2 toc-link" data-title="Refs">Do-sync</a>
                  </li>
                  <li>
                    <a href="#alter" class="toc-h2 toc-link" data-title="Refs">Alter</a>
                  </li>
                  <li>
                    <a href="#transaction" class="toc-h2 toc-link" data-title="Refs">Transaction</a>
                  </li>
              </ul>
          </li>
          <li>
            <a href="#java" class="toc-h1 toc-link" data-title="Java">Java</a>
              <ul class="toc-list-h2">
                  <li>
                    <a href="#instantiation" class="toc-h2 toc-link" data-title="Java">Instantiation</a>
                  </li>
                  <li>
                    <a href="#method-invocation" class="toc-h2 toc-link" data-title="Java">Method invocation</a>
                  </li>
              </ul>
          </li>
          <li>
            <a href="#many-thanks" class="toc-h1 toc-link" data-title="Many Thanks">Many Thanks</a>
          </li>
      </div>
        <ul class="toc-footer">
            <li>Powered by <a href='https://github.com/tripit/slate'>Slate</a></li>
            <li>Hosted on <a href='https://github.com/kimh/clojure-by-example'>Github</a></li>
            <li>Made by <a href='http://kimh.github.io/about/'>Hirokuni Kim</a></li>
        </ul>
    </div>
    <div class="page-wrapper">
      <div class="dark-box"></div>
      <div class="content">
        <h1 id='about'>About</h1>
<p>I don&#39;t like reading thick O&#39;Reilly books when I start learning new programming languages. Rather, I like starting by writing small and dirty code. If you take this approach, having many simple code examples are extremely helpful because I can find answers to these questions very easily.</p>

<p><em>How can I define a function?</em></p>

<p><em>What&#39;s the syntax for if and else?</em></p>

<p><em>Does the language support string interpolation?</em></p>

<p><em>What scopes of variables are available?</em></p>

<p>These are very basic questions, but enough to start hacking with the new languages.</p>

<p><br></p>

<p>Recently, I needed to learn this completely new language <strong>Clojure</strong> but couldn&#39;t find what I wanted. So, I decided to create one while learning Clojure.</p>

<p>Clojure is a functional programming language and learning functional programming languages is sometimes hard if you&#39;ve only had experiences with imperative languages. I have paid careful attention to make this page easy to understand for people who don&#39;t have experiences with functional programming languages, so please don&#39;t hesitate to read this page even if you don&#39;t know anything about functional programming.</p>

<p>Hopefully, this page helps you learning functional programming and starting to write Clojure!</p>
<h1 id='hello-world'>Hello, world!</h1><pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"Hello, world!"</span><span class="p">)</span><span class="w">
</span><span class="n">Hello,</span><span class="w"> </span><span class="n">world!</span><span class="w">
</span><span class="n">nil</span><span class="w">




</span><span class="n">user&gt;</span><span class="w"> </span><span class="s">"h"</span><span class="w">
</span><span class="s">"h"</span><span class="w">

</span><span class="n">user&gt;</span><span class="w"> </span><span class="mi">100</span><span class="w">
</span><span class="mi">100</span><span class="w">

</span><span class="n">user&gt;</span><span class="w"> </span><span class="n">true</span><span class="w">
</span><span class="n">true</span><span class="w">
</span></code></pre>
<blockquote>
<p><a href="https://repl.it/GRYw/1">Run at repl.it</a></p>
</blockquote>

<p><br></p>

<p>Our first Clojure code is, of course, printing &quot;Hello, world!&quot;. Here, we invoke the <strong>function</strong> <code>println</code> with the <strong>argument</strong> <code>Hello, world!</code>. We call the invocation of function <strong><em>applying the function to data</em></strong> in Clojure or other functional programming language.</p>

<p><br>
<br></p>

<p>The entire line of the code <code>(....)</code> is called a <strong>form</strong> in Clojure. It&#39;s also called <strong>expression</strong> in a general sense, but there is no real problem to use them interchangeably.</p>

<p>You can think of form as something that returns a value. <code>&quot;h&quot;</code> <code>100</code> <code>true</code> are all forms as well.</p>
<h1 id='bindings'>Bindings</h1>
<p>Giving names to values is called <strong>assignment</strong> in many programming languages. However, we call the mapping between names and values  <strong>binding</strong> in Clojure.</p>
<h2 id='symbol'>Symbol</h2>
<p>Symbols are used to bind names to values. <code>a</code> <code>b</code> <code>my-cool-function</code> <code>nyncat</code>: they are all symbols in Clojure.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">type</span><span class="w"> </span><span class="ss">'a</span><span class="p">)</span><span class="w">
</span><span class="n">clojure.lang.Symbol</span><span class="w">

</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">type</span><span class="w"> </span><span class="ss">'b</span><span class="p">)</span><span class="w">
</span><span class="n">clojure.lang.Symbol</span><span class="w">

</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">type</span><span class="w"> </span><span class="ss">'my-cool-function</span><span class="p">)</span><span class="w">
</span><span class="n">clojure.lang.Symbol</span><span class="w">

</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">type</span><span class="w"> </span><span class="ss">'nyncat</span><span class="p">)</span><span class="w">
</span><span class="n">clojure.lang.Symbol</span><span class="w">
</span></code></pre>
<p><br></p>

<p><code>&#39;</code> will prevent a form from being evaluated. We are doing this here because we want to treat symbols as data in order to pass them to <code>type</code> function.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="s">"aaaaa"</span><span class="p">)</span><span class="w">
</span><span class="o">#</span><span class="ss">'user/a</span><span class="w">

</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w">
</span><span class="n">aaaaa</span><span class="w">
</span><span class="n">nil</span><span class="w">

</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w">
</span><span class="n">CompilerException</span><span class="w"> </span><span class="n">java.lang.RuntimeException</span><span class="err">:</span><span class="w"> </span><span class="n">Unable</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="nb">resolve</span><span class="w"> </span><span class="nb">symbol</span><span class="err">:</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="n">context,</span><span class="w"> </span><span class="n">compiling</span><span class="err">:</span><span class="p">(</span><span class="nf">NO_SOURCE_PATH</span><span class="no">:1:1</span><span class="p">)</span><span class="w">
</span></code></pre>
<p><br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br></p>

<p>If you don&#39;t prepend a <code>&#39;</code> single quote, you are telling Clojure to resolve the symbol. You can obtain bound values by resolving symbols.</p>

<p><br></p>

<p>When we try to resolve symbols that are not bound to anything, Clojure complains with the exception.</p>
<h2 id='let'>Let</h2><pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">l</span><span class="w"> </span><span class="s">"light"</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="p">(</span><span class="nb">str</span><span class="w"> </span><span class="s">"God said let there be "</span><span class="w"> </span><span class="n">l</span><span class="p">)))</span><span class="w">
</span><span class="n">God</span><span class="w"> </span><span class="n">said</span><span class="w"> </span><span class="k">let</span><span class="w"> </span><span class="n">there</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">light</span><span class="w">
</span><span class="n">nil</span><span class="w">
</span></code></pre>
<p><br></p>

<p>To bind values to names, use <code>let</code>. Let takes a vector which takes a symbol in the first element and a value in the second element.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="n">l</span><span class="p">)</span><span class="w">

</span><span class="n">CompilerException</span><span class="w"> </span><span class="n">java.lang.RuntimeException</span><span class="err">:</span><span class="w"> </span><span class="n">Unable</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="nb">resolve</span><span class="w"> </span><span class="nb">symbol</span><span class="err">:</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="n">context,</span><span class="w"> </span><span class="n">compiling</span><span class="err">:</span><span class="p">(</span><span class="nf">NO_SOURCE_PATH</span><span class="no">:1:1</span><span class="p">)</span><span class="w">
</span></code></pre>
<p><br>
<br></p>

<p>You cannot resolve the symbol outside the let. This behavior is very similar to <em>private variable</em> in other programming languages.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">l</span><span class="w"> </span><span class="s">"light"</span><span class="w">
             </span><span class="n">d</span><span class="w"> </span><span class="s">"darkness"</span><span class="p">]</span><span class="w">
             </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="p">(</span><span class="nb">str</span><span class="w"> </span><span class="s">"God said let there be "</span><span class="w"> </span><span class="n">l</span><span class="p">))</span><span class="w">
             </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="p">(</span><span class="nb">str</span><span class="w"> </span><span class="s">"God also said let there be "</span><span class="w"> </span><span class="n">d</span><span class="p">)))</span><span class="w">
</span><span class="n">God</span><span class="w"> </span><span class="n">said</span><span class="w"> </span><span class="k">let</span><span class="w"> </span><span class="n">there</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">light</span><span class="w">
</span><span class="n">God</span><span class="w"> </span><span class="n">also</span><span class="w"> </span><span class="n">said</span><span class="w"> </span><span class="k">let</span><span class="w"> </span><span class="n">there</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">darkness</span><span class="w">
</span><span class="n">nil</span><span class="w">
</span></code></pre>
<p><br>
<br>
<br></p>

<p>You can also provide multiple bindings.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">l</span><span class="w"> </span><span class="s">"light"</span><span class="w">
            </span><span class="n">l_d</span><span class="w"> </span><span class="p">(</span><span class="nb">str</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="s">" and"</span><span class="w"> </span><span class="s">" darkness"</span><span class="p">)]</span><span class="w">
            </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="p">(</span><span class="nb">str</span><span class="w"> </span><span class="s">"God also said let there be "</span><span class="w"> </span><span class="n">l_d</span><span class="p">)))</span><span class="w">
</span><span class="n">God</span><span class="w"> </span><span class="n">also</span><span class="w"> </span><span class="n">said</span><span class="w"> </span><span class="k">let</span><span class="w"> </span><span class="n">there</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">light</span><span class="w"> </span><span class="nb">and</span><span class="w"> </span><span class="n">darkness</span><span class="w">
</span><span class="n">nil</span><span class="w">
</span></code></pre>
<p><br>
<br>
<br>
<br>
<br>
<br>
<br></p>

<p>The binding will be immediately available, so each binding can see the prior bindings.</p>
<h2 id='scope'>Scope</h2>
<p>When Clojure tries to resolve a symbol, the resolution will be done in the <strong>scope</strong> of the symbol.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="w"> </span><span class="s">"aaa"</span><span class="p">]</span><span class="w">
        </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="n">a</span><span class="p">))</span><span class="w">
</span><span class="n">aaa</span><span class="w">
</span><span class="n">nil</span><span class="w">
</span></code></pre>
<p><br></p>

<p>Clojure tries to evaluate <code>a</code> because it needs to pass the value to <code>println</code>. <code>a</code> is bound to <code>&quot;aaa&quot;</code>, so &quot;aaa&quot; is printed in your terminal. Very straight forward.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="w"> </span><span class="s">"aaa"</span><span class="p">]</span><span class="w">
        </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="w"> </span><span class="s">"AAA"</span><span class="p">]</span><span class="w">
          </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="n">a</span><span class="p">)))</span><span class="w">

</span><span class="n">AAA</span><span class="w">
</span><span class="n">nil</span><span class="w">
</span></code></pre>
<p><br>
<br>
<br></p>

<p>Now, <code>let</code> are nested. Like previous example, Clojure tries to resolve <code>a</code>. However, this time Clojure resolves <code>a</code> to <code>&quot;AAA&quot;</code>, instead of <code>aaa</code>. Each <code>let</code> will create a scope and symbol resolution is done inside the let where the symbol is resolved.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="w"> </span><span class="s">"aaa"</span><span class="p">]</span><span class="w">
        </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="w"> </span><span class="s">"AAA"</span><span class="p">]</span><span class="w">
          </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="n">a</span><span class="p">))</span><span class="w">
        </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="n">a</span><span class="p">))</span><span class="w">
</span><span class="n">AAA</span><span class="w">
</span><span class="n">aaa</span><span class="w">
</span><span class="n">nil</span><span class="w">
</span></code></pre>
<p><br>
<br>
<br>
<br></p>

<p>Also notice that the inner <code>let</code> does not override the scope of outer <code>let</code>.</p>

<p><br>
<br>
<br>
<br>
<br></p>

<p>This kind of scope is called <strong>lexical scope</strong>. For those whom English is not your first language, lexical means <em>words in a sentence</em>. The scope is <strong>lexical</strong> because the compiler relies on the physical location of the symbol (word) in a program (sentence) to resolve them.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="w"> </span><span class="s">"a"</span><span class="p">]</span><span class="w">
        </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[]</span><span class="w">
          </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="n">a</span><span class="p">)))</span><span class="w">
</span><span class="n">a</span><span class="w">
</span><span class="n">nil</span><span class="w">
</span></code></pre>
<p><br></p>

<p>The resolution look up bubbles up until it finds the binding. The inner <code>let</code> doesn&#39;t provide the binding for <code>a</code>, so it bubbles up to the outer <code>let</code>. This happens because the scope of inner let is wrapped by the scope of outer <code>let</code>.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="w"> </span><span class="s">"a"</span><span class="p">]</span><span class="w">
        </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[]</span><span class="w">
          </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="n">not-bound-symbol</span><span class="p">)))</span><span class="w">
</span><span class="n">CompilerException</span><span class="w"> </span><span class="n">java.lang.RuntimeException</span><span class="err">:</span><span class="w"> </span><span class="n">Unable</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="nb">resolve</span><span class="w"> </span><span class="nb">symbol</span><span class="err">:</span><span class="w"> </span><span class="n">not-bound-symbol</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="n">context,</span><span class="w"> </span><span class="n">compiling</span><span class="err">:</span><span class="p">(</span><span class="nf">NO_SOURCE_PATH</span><span class="no">:3:11</span><span class="p">)</span><span class="w">
</span></code></pre>
<p><br>
<br>
<br></p>

<p>Clojure complains with <strong>Unable to resolve symbol</strong> exception when it cannot find the binding inside the given scope.</p>

<p><br>
<br>
<br></p>

<p>You probably find the idea of lexical scope very familiar. This is because most modern programming languages use lexical scope. There is also something called <em>dynamic scope</em> but you probably don&#39;t have to know that right now.</p>
<h2 id='def'>Def</h2><pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">object</span><span class="w"> </span><span class="s">"light"</span><span class="p">)</span><span class="w">
</span><span class="o">#</span><span class="ss">'user/object</span><span class="w">

</span><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="p">(</span><span class="nb">str</span><span class="w"> </span><span class="s">"God said let there be "</span><span class="w"> </span><span class="n">object</span><span class="p">))</span><span class="w">
</span><span class="n">God</span><span class="w"> </span><span class="n">said</span><span class="w"> </span><span class="k">let</span><span class="w"> </span><span class="n">there</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">light</span><span class="w">
</span><span class="n">nil</span><span class="w">
</span></code></pre>
<p><br></p>

<p>You can also bind symbols to values with <code>def</code>. While you can access the symbol only from within the <code>let</code> where it&#39;s declared , you can access the symbol declared with <code>def</code> from anywhere.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">object</span><span class="w"> </span><span class="s">"darkness"</span><span class="p">)</span><span class="w">
</span><span class="o">#</span><span class="ss">'user/object</span><span class="w">

</span><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="p">(</span><span class="nb">str</span><span class="w"> </span><span class="s">"God said let there be "</span><span class="w"> </span><span class="n">object</span><span class="p">))</span><span class="w">
</span><span class="n">God</span><span class="w"> </span><span class="n">said</span><span class="w"> </span><span class="k">let</span><span class="w"> </span><span class="n">there</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">darkness</span><span class="w">
</span><span class="n">nil</span><span class="w">
</span></code></pre>
<p><br>
<br>
<br>
<br>
<br></p>

<p>You can also override the one already declared later.</p>

<p><br>
<br>
<br>
<br></p>

<p>The rule of thumb in Clojure is avoiding the use of <code>def</code> as much as possible. <code>def</code> introduces state and abusing state will make our code difficult to maintain.</p>
<h1 id='functions'>Functions</h1><h2 id='defn'>Defn</h2><pre class="highlight clojure tab-clojure"><code><span class="w">

</span><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">say-hello</span><span class="w">
         </span><span class="p">[</span><span class="nb">name</span><span class="p">]</span><span class="w">
         </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="p">(</span><span class="nb">str</span><span class="w"> </span><span class="s">"Hello, "</span><span class="w"> </span><span class="nb">name</span><span class="p">)))</span><span class="w">

</span><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">say-hello</span><span class="w"> </span><span class="s">"Kim"</span><span class="p">)</span><span class="w">
</span><span class="n">Hello,</span><span class="w"> </span><span class="n">Kim</span><span class="w">
</span><span class="n">nil</span><span class="w">
</span></code></pre>
<p><br></p>

<p>To define a function, use <code>defn</code>.</p>

<p>The first argument is the name of function <code>say-hello</code>, the second argument is the argument of the function <code>[name]</code>, and the third argument is the function body <code>(println (str &quot;Hello, &quot; name))</code>.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">say-hello</span><span class="w">
         </span><span class="s">"Takes name argument and say hello to the name"</span><span class="w">
         </span><span class="p">[</span><span class="nb">name</span><span class="p">]</span><span class="w">
         </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="p">(</span><span class="nb">str</span><span class="w"> </span><span class="s">"Hello, "</span><span class="w"> </span><span class="nb">name</span><span class="p">)))</span><span class="w">
</span></code></pre>
<p><br>
<br>
<br>
<br>
<br></p>

<p>You can also add documentation.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">doc</span><span class="w"> </span><span class="n">say-hello</span><span class="p">)</span><span class="w">
</span><span class="n">-------------------------</span><span class="w">
</span><span class="n">user/say-hello</span><span class="w">
</span><span class="p">([</span><span class="nb">name</span><span class="p">])</span><span class="w">
  </span><span class="n">Takes</span><span class="w"> </span><span class="nb">name</span><span class="w"> </span><span class="n">argument</span><span class="w"> </span><span class="nb">and</span><span class="w"> </span><span class="n">say</span><span class="w"> </span><span class="n">hello</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="nb">name</span><span class="w">
</span><span class="n">nil</span><span class="w">
</span></code></pre>
<p><br>
<br>
<br>
<br></p>

<p>Use <code>doc</code> to read the documentation.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">say-hello</span><span class="w">
         </span><span class="s">"Takes name argument and say hello to the name"</span><span class="w">
         </span><span class="p">{</span><span class="no">:added</span><span class="w"> </span><span class="s">"1.0"</span><span class="w">
          </span><span class="no">:static</span><span class="w"> </span><span class="n">true</span><span class="p">}</span><span class="w">
         </span><span class="p">[</span><span class="nb">name</span><span class="p">]</span><span class="w">
         </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="p">(</span><span class="nb">str</span><span class="w"> </span><span class="s">"Hello, "</span><span class="w"> </span><span class="nb">name</span><span class="p">)))</span><span class="w">
</span></code></pre>
<p><br>
<br>
<br>
<br>
<br>
<br></p>

<p>You can also add metadata of the function.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">meta</span><span class="w"> </span><span class="p">(</span><span class="nf">var</span><span class="w"> </span><span class="n">say-hello</span><span class="p">))</span><span class="w">
</span><span class="p">{</span><span class="no">:added</span><span class="w"> </span><span class="s">"1.0"</span><span class="n">,</span><span class="w"> </span><span class="no">:ns</span><span class="w"> </span><span class="o">#</span><span class="n">&lt;Namespace</span><span class="w"> </span><span class="n">user&gt;,</span><span class="w"> </span><span class="no">:name</span><span class="w"> </span><span class="n">say-hello,</span><span class="w"> </span><span class="no">:file</span><span class="w"> </span><span class="s">"NO_SOURCE_PATH"</span><span class="n">,</span><span class="w"> </span><span class="no">:static</span><span class="w"> </span><span class="n">true,</span><span class="w"> </span><span class="no">:column</span><span class="w"> </span><span class="mi">1</span><span class="n">,</span><span class="w"> </span><span class="no">:line</span><span class="w"> </span><span class="mi">1</span><span class="n">,</span><span class="w"> </span><span class="no">:arglists</span><span class="w"> </span><span class="p">([</span><span class="nb">name</span><span class="p">])</span><span class="n">,</span><span class="w"> </span><span class="no">:doc</span><span class="w"> </span><span class="s">"Takes name argument and say hello to the name"</span><span class="p">}</span><span class="w">
</span></code></pre>
<p><br>
<br>
<br>
<br>
<br>
<br></p>

<p>You can expand the metadata with <code>meta</code>. Notice that <code>say-hello</code> is first passed to <code>var</code>. This is because <code>meta</code> expects it&#39;s argument to be var object, not value, and <code>var</code> will turn the passed symbol into var object.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">meta</span><span class="w"> </span><span class="o">#</span><span class="ss">'say-hello</span><span class="p">)</span><span class="w">
</span><span class="p">{</span><span class="no">:added</span><span class="w"> </span><span class="s">"1.0"</span><span class="n">,</span><span class="w"> </span><span class="no">:ns</span><span class="w"> </span><span class="o">#</span><span class="n">&lt;Namespace</span><span class="w"> </span><span class="n">user&gt;,</span><span class="w"> </span><span class="no">:name</span><span class="w"> </span><span class="n">say-hello,</span><span class="w"> </span><span class="no">:file</span><span class="w"> </span><span class="s">"NO_SOURCE_PATH"</span><span class="n">,</span><span class="w"> </span><span class="no">:static</span><span class="w"> </span><span class="n">true,</span><span class="w"> </span><span class="no">:column</span><span class="w"> </span><span class="mi">1</span><span class="n">,</span><span class="w"> </span><span class="no">:line</span><span class="w"> </span><span class="mi">1</span><span class="n">,</span><span class="w"> </span><span class="no">:arglists</span><span class="w"> </span><span class="p">([</span><span class="nb">name</span><span class="p">])</span><span class="n">,</span><span class="w"> </span><span class="no">:doc</span><span class="w"> </span><span class="s">"Takes name argument and say hello to the name"</span><span class="p">}</span><span class="w">
</span></code></pre>
<p><br></p>

<p><code>#&#39;</code> is the reader macro for <code>var</code> and works the exactly same.</p>
<h2 id='anonymous-function'>Anonymous Function</h2>
<p>Functions are first class objects in Clojure. When you say something is <em>a first class object in programming language X</em>, it means that you can do all the basic operations with the object
such as passing it to a function, returned from a function, and binding it to a variable, etc.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"Hello world"</span><span class="p">))</span><span class="w">
</span><span class="o">#</span><span class="n">&lt;user$eval3663$fn__3664</span><span class="w"> </span><span class="n">user$eval3663$fn__3664</span><span class="err">@</span><span class="mi">5</span><span class="n">de5bfa4&gt;</span><span class="w">
</span></code></pre>
<p><br></p>

<p>To create a function object, use <code>fn</code>.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">hello-world-func</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"Hello world"</span><span class="p">)))</span><span class="w">
</span><span class="o">#</span><span class="ss">'user/hello-world-func</span><span class="w">

</span><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">hello-world-func</span><span class="p">)</span><span class="w">
</span><span class="n">Hello</span><span class="w"> </span><span class="n">world</span><span class="w">
</span><span class="n">nil</span><span class="w">
</span></code></pre>
<p><br>
<br></p>

<p>You can bind functions to var just like other values. This works just like <code>defn</code></p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="o">#</span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w">
</span><span class="o">#</span><span class="n">&lt;user$eval2902$fn__2903</span><span class="w"> </span><span class="n">user$eval2902$fn__2903</span><span class="err">@</span><span class="mi">1</span><span class="n">cc9a623&gt;</span><span class="w">

</span><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span><span class="w">
</span><span class="o">#</span><span class="n">&lt;user$eval2920$fn__2921</span><span class="w"> </span><span class="n">user$eval2920$fn__2921</span><span class="err">@</span><span class="mi">40</span><span class="n">bd9db&gt;</span><span class="w">
</span></code></pre>
<p><br>
<br>
<br>
<br>
<br>
<br></p>

<p><code>#()</code> is the shortcut for <code>fn</code>.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="o">#</span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">%</span><span class="p">)</span><span class="w">
</span><span class="o">#</span><span class="n">&lt;user$eval2930$fn__2931</span><span class="w"> </span><span class="n">user$eval2930$fn__2931</span><span class="err">@</span><span class="mi">3</span><span class="n">e445ad7&gt;</span><span class="w">

</span><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">plus</span><span class="w"> </span><span class="o">#</span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">%</span><span class="p">)]</span><span class="w">
         </span><span class="p">(</span><span class="nf">plus</span><span class="w"> </span><span class="mi">10</span><span class="p">))</span><span class="w">
</span><span class="mi">11</span><span class="w">

</span><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">plus-numbers</span><span class="w"> </span><span class="o">#</span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">%1</span><span class="w"> </span><span class="n">%2</span><span class="w"> </span><span class="n">%3</span><span class="p">)]</span><span class="w">
         </span><span class="p">(</span><span class="nf">plus-numbers</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="mi">20</span><span class="w"> </span><span class="mi">30</span><span class="p">))</span><span class="w">
</span><span class="mi">61</span><span class="w">
</span></code></pre>
<p><br>
<br>
<br>
<br>
<br></p>

<p><code>%</code> will be replaced with arguments passed to the function. When the function takes multiple arguments, <code>%1</code> is for the first argument, <code>%2</code> is for the second and so on.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">say-hello</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="nb">name</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="p">(</span><span class="nb">str</span><span class="w"> </span><span class="s">"Hello, "</span><span class="w"> </span><span class="nb">name</span><span class="p">))))</span><span class="w">
</span><span class="o">#</span><span class="ss">'user/say-hello</span><span class="w">

</span><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">say-bye</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="nb">name</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="p">(</span><span class="nb">str</span><span class="w"> </span><span class="s">"Good bye, "</span><span class="w"> </span><span class="nb">name</span><span class="p">))))</span><span class="w">
</span><span class="o">#</span><span class="ss">'user/say-bye</span><span class="w">

</span><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">greeting</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">greeting-func</span><span class="w"> </span><span class="nb">name</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nf">greeting-func</span><span class="w"> </span><span class="nb">name</span><span class="p">)))</span><span class="w">
</span><span class="o">#</span><span class="ss">'user/greeting-to-kim</span><span class="w">

</span><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">greeting</span><span class="w"> </span><span class="n">say-hello</span><span class="w"> </span><span class="s">"Kim"</span><span class="p">)</span><span class="w">
</span><span class="n">Hello,</span><span class="w"> </span><span class="n">Kim</span><span class="w">
</span><span class="n">nil</span><span class="w">

</span><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">greeting</span><span class="w"> </span><span class="n">say-bye</span><span class="w"> </span><span class="s">"Kim"</span><span class="p">)</span><span class="w">
</span><span class="n">Good</span><span class="w"> </span><span class="n">bye,</span><span class="w"> </span><span class="n">Kim</span><span class="w">
</span><span class="n">nil</span><span class="w">
</span></code></pre>
<p><br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br></p>

<p>You can also pass a function to another function. We define two functions and bind to <code>say-hello</code> and <code>say-bye</code> vars. We also define a generic function and bind to <code>greeting</code>.</p>

<p><br>
<br>
<br>
<br>
<br></p>

<p>Then we pass <code>say-hello</code> and <code>say-bye</code> to <code>greeting</code>.</p>
<h2 id='closure'>Closure</h2>
<p>When a function (let&#39;s call this <em>inner</em> function) is returned from another function (let&#39;s call this <em>outer</em> function), and the inner function does somethings with the arguments given from outer function, then the inner function is called a <strong>closure</strong>.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">inner</span><span class="w">
         </span><span class="p">[</span><span class="n">from-outer</span><span class="p">]</span><span class="w">
         </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="n">from-outer</span><span class="p">)))</span><span class="w">
</span><span class="o">#</span><span class="ss">'user/inner</span><span class="w">

</span><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">outer1</span><span class="w"> </span><span class="p">(</span><span class="nf">inner</span><span class="w"> </span><span class="s">"this is from outer"</span><span class="p">))</span><span class="w">
</span><span class="o">#</span><span class="ss">'user/outer1</span><span class="w">

</span><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">outer2</span><span class="w"> </span><span class="p">(</span><span class="nf">inner</span><span class="w"> </span><span class="s">"this is yet another from outer"</span><span class="p">))</span><span class="w">
</span><span class="o">#</span><span class="ss">'user/outer2</span><span class="w">

</span><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">outer1</span><span class="p">)</span><span class="w">
</span><span class="n">this</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="n">outer</span><span class="w">
</span><span class="n">nil</span><span class="w">

</span><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">outer2</span><span class="p">)</span><span class="w">
</span><span class="n">this</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">yet</span><span class="w"> </span><span class="n">another</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="n">outer</span><span class="w">
</span><span class="n">nil</span><span class="w">
</span></code></pre>
<p><br></p>

<p>We define a function called <code>inner</code>. <code>inner</code> function prints <code>from-outer</code> var which is supposed to be given by the outer function.</p>

<p><br>
<br></p>

<p>We also define two functions, <code>outer1</code> and <code>outer2</code>. These functions both call <code>inner</code> but with different arguments.</p>

<p><br>
<br></p>

<p>As a result, even if the <code>from-outer</code> var doesn&#39;t change, <code>inner</code> prints different things.</p>
<h1 id='namespaces'>Namespaces</h1>
<p><strong>Namespace</strong> provides a way to organize different Clojure objects into to logical groups. These logical groups often are called <strong>library</strong> and can be used from other namespaces. A namespace is constructed of symbols chained by <code>.</code>. <code>clojure.core</code>, <code>clojure-http.client</code>, <code>my.app.example</code>: they are all namespaces.</p>
<h2 id='create-ns'>Create-ns</h2><pre class="highlight clojure tab-clojure"><code><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">create-ns</span><span class="w"> </span><span class="ss">'clojure.by.example</span><span class="p">)</span><span class="w">
</span><span class="n">nil</span><span class="w">
</span></code></pre>
<p><br></p>

<p>To create a namespace, use <code>create-ns</code>. However, it is rare to create a namespace with <code>create-ns</code> because there is more handy <code>ns</code> macro which will be explained later. You need to place a single quote before a namespace in order to stop resolving the namespace symbol. See <a href="#quotes">Quotes</a> for more details about quoting.</p>
<h2 id='in-ns'>In-ns</h2><pre class="highlight clojure tab-clojure"><code><span class="n">clojure.by.example&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">in-ns</span><span class="w"> </span><span class="ss">'user</span><span class="p">)</span><span class="w">
</span><span class="o">#</span><span class="n">object</span><span class="p">[</span><span class="n">clojure.lang.Namespace</span><span class="w"> </span><span class="mi">0</span><span class="n">x2522a678</span><span class="w"> </span><span class="s">"user"</span><span class="p">]</span><span class="w">

</span><span class="n">user&gt;</span><span class="w">
</span></code></pre>
<p><br></p>

<p>To move to a specific namespace, use <code>in-ns</code>.</p>
<h2 id='require'>Require</h2>
<p>One of the important roles of namespace is providing a scope for Clojure objects.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">clojure.by.example&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">favorite-language</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="s">"Clojure!!"</span><span class="p">)</span><span class="w">
</span><span class="o">#</span><span class="ss">'clojure.by.example/favorite-language</span><span class="w">

</span><span class="n">clojure.by.example&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">favorite-language</span><span class="p">)</span><span class="w">
</span><span class="s">"Clojure!!"</span><span class="w">

</span><span class="n">clojure.by.example&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">in-ns</span><span class="w"> </span><span class="ss">'user</span><span class="p">)</span><span class="w">
</span><span class="o">#</span><span class="n">object</span><span class="p">[</span><span class="n">clojure.lang.Namespace</span><span class="w"> </span><span class="mi">0</span><span class="n">x2522a678</span><span class="w"> </span><span class="s">"user"</span><span class="p">]</span><span class="w">

</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">favorite-language</span><span class="p">)</span><span class="w">
</span><span class="n">CompilerException</span><span class="w"> </span><span class="n">java.lang.RuntimeException</span><span class="err">:</span><span class="w"> </span><span class="n">Unable</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="nb">resolve</span><span class="w"> </span><span class="nb">symbol</span><span class="err">:</span><span class="w"> </span><span class="n">favorite-language</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="n">context,</span><span class="w"> </span><span class="n">compiling</span><span class="err">:</span><span class="p">(</span><span class="nf">*cider-repl</span><span class="w"> </span><span class="n">localhost*</span><span class="no">:501:7</span><span class="p">)</span><span class="w">
</span></code></pre>
<p><br></p>

<p>Things that you define in a namespace is not visible from other namespaces by default. As you can see in this example, <code>favorite-language</code> function is not visible from <code>user</code> namespace.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="ss">'clojure.by.example</span><span class="p">)</span><span class="w">
</span><span class="n">nil</span><span class="w">

</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">clojure.by.example/favorite-language</span><span class="p">)</span><span class="w">
</span><span class="s">"Clojure!!"</span><span class="w">
</span></code></pre>
<p><br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br></p>

<p>To load other namespaces, use <code>require</code>. Once you load <code>clojure.by.example</code> namespace, <code>favorite-language</code> will be available from <code>user</code> namespace.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">clojure.by.example</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">cbe</span><span class="p">])</span><span class="w">
</span><span class="n">nil</span><span class="w">

</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">cbe/favorite-language</span><span class="p">)</span><span class="w">
</span><span class="s">"Clojure!!"</span><span class="w">
</span></code></pre>
<p><br>
<br>
<br>
<br></p>

<p>Sometimes you want to give a different name to a loaded namespace. In such a case, you can surround the namespace by a vector with <code>:as</code> keyword.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">clojure.by.example</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">cbe</span><span class="p">]</span><span class="w">
               </span><span class="o">'</span><span class="p">[</span><span class="n">clojure.core</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">ccc</span><span class="p">])</span><span class="w">
</span><span class="n">nil</span><span class="w">
</span></code></pre>
<p><br>
<br>
<br>
<br></p>

<p>You can also require multiple namespaces at once.</p>
<h2 id='refer'>Refer</h2><pre class="highlight clojure tab-clojure"><code><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">refer</span><span class="w"> </span><span class="ss">'clojure.by.example</span><span class="p">)</span><span class="w">
</span><span class="n">nil</span><span class="w">

</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">favorite-language</span><span class="p">)</span><span class="w">
</span><span class="s">"Clojure!!"</span><span class="w">
</span></code></pre>
<p><br></p>

<p>You probably don&#39;t want to type <code>clojure.by.example</code> everytime you want to call <code>favorite-language</code> function. You can avoid this if you use <code>refer</code>.</p>
<h2 id='use'>Use</h2><pre class="highlight clojure tab-clojure"><code><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">use</span><span class="w"> </span><span class="ss">'clojure.by.example</span><span class="p">)</span><span class="w">
</span><span class="n">nil</span><span class="w">

</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">favorite-language</span><span class="p">)</span><span class="w">
</span><span class="s">"Clojure!!"</span><span class="w">
</span></code></pre>
<p><br></p>

<p><code>require</code> loads a namespace and <code>refer</code> refers the namespace. To do these at once, you can use <code>use</code>.</p>
<h2 id='import'>Import</h2><pre class="highlight clojure tab-clojure"><code><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">import</span><span class="w"> </span><span class="n">java.util.Date</span><span class="p">)</span><span class="w">
</span><span class="n">java.util.Date</span><span class="w">

</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">new</span><span class="w"> </span><span class="n">Date</span><span class="p">)</span><span class="w">
</span><span class="o">#</span><span class="n">inst</span><span class="w"> </span><span class="s">"2017-01-15T14:32:18.537-00:00"</span><span class="w">
</span></code></pre>
<p><br></p>

<p>To import a namespace of Java, you need to use <code>import</code>. Please see <a href="#java">Java</a> section for more information about how to use Java.</p>
<h2 id='ns'>Ns</h2>
<p><code>ns</code> macro creates a new namespace and gives you an opportunity to load other namespaces at the creation time.</p>
<pre class="highlight clojure tab-clojure"><code><span class="p">(</span><span class="nf">ns</span><span class="w"> </span><span class="n">example.namespace</span><span class="w">
  </span><span class="p">(</span><span class="no">:require</span><span class="w"> </span><span class="p">[</span><span class="n">clojure.java.io</span><span class="p">])</span><span class="w">
  </span><span class="p">(</span><span class="no">:use</span><span class="w"> </span><span class="p">[</span><span class="n">clojure.data</span><span class="p">])</span><span class="w">
  </span><span class="p">(</span><span class="no">:import</span><span class="w"> </span><span class="p">[</span><span class="n">java.util</span><span class="w"> </span><span class="n">List</span><span class="w"> </span><span class="n">Set</span><span class="p">]))</span><span class="w">
</span></code></pre>
<p><br></p>

<p><code>ns</code> can take <code>:require</code>, <code>:use</code>, and <code>:import</code> keyword. They work the same way as the corresponding functions explained above except you don&#39;t need to quote.</p>
<h1 id='control-flow'>Control Flow</h1><h2 id='if'>If</h2><pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="n">true</span><span class="w">
         </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"This is always printed"</span><span class="p">)</span><span class="w">
         </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"This is never printed"</span><span class="p">))</span><span class="w">
</span><span class="n">This</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">always</span><span class="w"> </span><span class="n">printed</span><span class="w">
</span><span class="n">nil</span><span class="w">
</span></code></pre>
<p><br></p>

<p><code>if</code> takes a predicate (<code>true</code> or <code>false</code>) as the first argument. The second argument will be evaluated if the predicate is evaluated to <code>true</code>. The third argument is equivalent to <strong>else</strong> in many programming languages which is evaluated when the predicate evaluates to <code>false</code>.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="n">true</span><span class="w">
         </span><span class="p">(</span><span class="nf">do</span><span class="w">
         </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"one"</span><span class="p">)</span><span class="w">
         </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"two"</span><span class="p">)))</span><span class="w">
</span><span class="n">one</span><span class="w">
</span><span class="n">two</span><span class="w">
</span><span class="n">nil</span><span class="w">
</span></code></pre>
<p><br>
<br>
<br></p>

<p>In Clojure, you can only pass one expression to a branch of <code>if</code>. However, you often need to pass more than one expression in real programs. In this case, use <code>do</code>.</p>
<h2 id='if-let'>If-Let</h2><pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">positive-number</span><span class="w"> </span><span class="p">[</span><span class="n">numbers</span><span class="p">]</span><span class="w">
         </span><span class="p">(</span><span class="nb">if-let</span><span class="w"> </span><span class="p">[</span><span class="n">pos-nums</span><span class="w"> </span><span class="p">(</span><span class="nf">not-empty</span><span class="w"> </span><span class="p">(</span><span class="nb">filter</span><span class="w"> </span><span class="nb">pos?</span><span class="w"> </span><span class="n">numbers</span><span class="p">))]</span><span class="w">
           </span><span class="n">pos-nums</span><span class="w">
           </span><span class="s">"no positive numbers"</span><span class="p">))</span><span class="w">

</span><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">positive-number</span><span class="w"> </span><span class="p">[</span><span class="mi">-1</span><span class="w"> </span><span class="mi">-2</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="p">])</span><span class="w">
</span><span class="p">(</span><span class="nf">1</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w">

</span><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">positive-number-seq</span><span class="w"> </span><span class="p">[</span><span class="mi">-1</span><span class="w"> </span><span class="mi">-2</span><span class="p">])</span><span class="w">
</span><span class="s">"no positive numbers"</span><span class="w">
</span></code></pre>
<p><br></p>

<p>After testing condition, you often want to use the result of the testing later. <code>if-let</code> binds the evaluated condition to var when it&#39;s truthy. In this example, when <code>positive-number</code> receives a collection which contains positive numbers, the result of <code>(not-empty (filter pos? numbers))</code> will be bound to <code>pos-nums</code>.</p>

<p><code>pos-nums</code> is returned since the collection contains positive numbers <code>1 2</code>.
<br>
<br>
<br>
The second argument is for <strong>else</strong> branch. It will be evaluated when the first argument is evaluated to be false.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">boolean</span><span class="w"> </span><span class="p">(</span><span class="nb">filter</span><span class="w"> </span><span class="nb">pos?</span><span class="w"> </span><span class="p">[</span><span class="mi">-1</span><span class="p">]))</span><span class="w">
</span><span class="n">true</span><span class="w">

</span><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">not-empty</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="p">])</span><span class="w">
</span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="w">

</span><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">not-empty</span><span class="w"> </span><span class="p">[])</span><span class="w">
</span><span class="n">nil</span><span class="w">
</span></code></pre>
<p><br></p>

<p>Note that <code>filter</code> returns an empty sequence when no value matches the condition instead of <code>nil</code> and an empty sequence is not falsey in Clojure. But, in order to reach the else branch of <code>if-let</code>, <code>pos-nums</code> has to be <code>nil</code>. For this reason, we are using <code>not-empty</code> which properly returns nil if the sequence is empty.</p>
<h2 id='when'>When</h2><pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">when</span><span class="w"> </span><span class="n">true</span><span class="w">
         </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"one"</span><span class="p">)</span><span class="w">
         </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"two"</span><span class="p">))</span><span class="w">
</span><span class="n">one</span><span class="w">
</span><span class="n">two</span><span class="w">
</span><span class="n">nil</span><span class="w">
</span></code></pre>
<p><br></p>

<p>When you only care about the case when the condition is truthy, you can use <code>when</code>. <code>when</code> is similar to <code>if</code> but does not contain an <strong>else</strong> branch and is already wrapped by <code>do</code>, so you can pass multiple expressions.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">when</span><span class="w"> </span><span class="n">false</span><span class="w">
         </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"one"</span><span class="p">)</span><span class="w">
         </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"two"</span><span class="p">))</span><span class="w">
</span><span class="n">nil</span><span class="w">
</span></code></pre>
<p><br>
<br>
<br>
<br></p>

<p>Since there is no <strong>else</strong> branch, this doesn&#39;t do anything.</p>
<h2 id='when-let'>When-Let</h2><pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">when-let</span><span class="w"> </span><span class="p">[</span><span class="n">pos-nums</span><span class="w"> </span><span class="p">(</span><span class="nb">filter</span><span class="w"> </span><span class="nb">pos?</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="mi">-1</span><span class="w"> </span><span class="mi">-2</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="p">])]</span><span class="w">
          </span><span class="n">pos-nums</span><span class="w">
          </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"one"</span><span class="p">)</span><span class="w">
          </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"two"</span><span class="p">))</span><span class="w">
</span><span class="n">one</span><span class="w">
</span><span class="n">two</span><span class="w">
</span><span class="n">nil</span><span class="w">
</span></code></pre>
<p><br></p>

<p>There is also <code>when-let</code> which is similar to <code>if-let</code> but does not contain an <strong>else</strong> branch.</p>
<h2 id='case'>Case</h2><pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">case-test-1</span><span class="w">
         </span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="w">
         </span><span class="p">(</span><span class="nf">case</span><span class="w"> </span><span class="n">n</span><span class="w">
            </span><span class="mi">1</span><span class="w"> </span><span class="s">"n is 1"</span><span class="w">
            </span><span class="mi">2</span><span class="w"> </span><span class="s">"n is 2"</span><span class="w">
            </span><span class="s">"n is other"</span><span class="p">))</span><span class="w">
</span><span class="o">#</span><span class="ss">'user/case-test-1</span><span class="w">

</span><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="p">(</span><span class="nf">case-test-1</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span><span class="w">
</span><span class="n">n</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="mi">1</span><span class="w">
</span><span class="n">nil</span><span class="w">

</span><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="p">(</span><span class="nf">case-test-1</span><span class="w"> </span><span class="mi">2</span><span class="p">))</span><span class="w">
</span><span class="n">n</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="mi">2</span><span class="w">
</span><span class="n">nil</span><span class="w">

</span><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="p">(</span><span class="nf">case-test-1</span><span class="w"> </span><span class="mi">3</span><span class="p">))</span><span class="w">
</span><span class="n">n</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">other</span><span class="w">
</span><span class="n">nil</span><span class="w">
</span></code></pre>
<p><br></p>

<p>There is also <code>case</code> which works pretty much the same as the one in other programming languages. <code>case</code> compares the value with each condition with <code>=</code>
and evaluates the expression in the matched branch.</p>

<p><br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
The expression in the last branch will be evaluated if none of the conditions are matched.</p>
<h2 id='cond'>Cond</h2><pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">cond-test</span><span class="w">
         </span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="w">
         </span><span class="p">(</span><span class="k">cond</span><span class="w">
           </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="s">"n is 1"</span><span class="w">
           </span><span class="p">(</span><span class="nb">and</span><span class="w"> </span><span class="p">(</span><span class="nb">&gt;</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">&lt;</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="mi">10</span><span class="p">))</span><span class="w"> </span><span class="s">"n is over 3 and under 10"</span><span class="w">
           </span><span class="no">:else</span><span class="w"> </span><span class="s">"n is other"</span><span class="p">))</span><span class="w">

</span><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="p">(</span><span class="nf">cond-test</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span><span class="w">
</span><span class="n">n</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="mi">1</span><span class="w">
</span><span class="n">nil</span><span class="w">

</span><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="p">(</span><span class="nf">cond-test</span><span class="w"> </span><span class="mi">5</span><span class="p">))</span><span class="w">
</span><span class="n">n</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">over</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="nb">and</span><span class="w"> </span><span class="n">under</span><span class="w"> </span><span class="mi">10</span><span class="w">
</span><span class="n">nil</span><span class="w">

</span><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="p">(</span><span class="nf">cond-test</span><span class="w"> </span><span class="mi">15</span><span class="p">))</span><span class="w">
</span><span class="n">n</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">other</span><span class="w">
</span><span class="n">nil</span><span class="w">
</span></code></pre>
<p><br></p>

<p>When you want to do similar thing to <code>case</code> but want to write your own test case rather than <code>=</code>, you can use <code>cond</code>. You can write a different test case in each branch with <code>cond</code>.</p>

<p><br>
<br>
You use <code>:else</code> keyword for the default case.</p>
<h2 id='condp'>Condp</h2><pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">condp-test-2</span><span class="w">
         </span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="w">
         </span><span class="p">(</span><span class="nf">condp</span><span class="w"> </span><span class="nb">contains?</span><span class="w"> </span><span class="n">n</span><span class="w">
           </span><span class="o">#</span><span class="p">{</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w"> </span><span class="s">"n is either 1 or 2 or 3"</span><span class="w">
           </span><span class="s">"n is not 1 or 2 or 3"</span><span class="p">))</span><span class="w">
</span><span class="o">#</span><span class="ss">'user/condp-test-2</span><span class="w">

</span><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="p">(</span><span class="nf">condp-test-2</span><span class="w"> </span><span class="mi">2</span><span class="p">))</span><span class="w">
</span><span class="n">n</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">either</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="nb">or</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="nb">or</span><span class="w"> </span><span class="mi">3</span><span class="w">
</span><span class="n">nil</span><span class="w">

</span><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="p">(</span><span class="nf">condp-test-2</span><span class="w"> </span><span class="mi">5</span><span class="p">))</span><span class="w">
</span><span class="n">n</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="nb">not</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="nb">or</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="nb">or</span><span class="w"> </span><span class="mi">3</span><span class="w">
</span><span class="n">nil</span><span class="w">
</span></code></pre>
<p><br></p>

<p>You can use a predicate with <code>condp</code> for condition. In this case <code>contains?</code> is the predicate.</p>

<p><br>
<br>
<br>
<br></p>

<p><code>(contains? #{1 2 3} 2)</code> will be evaluated in this case.</p>

<p><br>
<br></p>

<p><code>(contains? #{1 2 3} 5)</code> will be evaluated falsey, thus the default branch will be evaluated.</p>
<h1 id='boolean'>Boolean</h1><pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="n">true</span><span class="w">
</span><span class="n">true</span><span class="w">

</span><span class="n">user=&gt;</span><span class="w"> </span><span class="n">false</span><span class="w">
</span><span class="n">false</span><span class="w">
</span></code></pre>
<p><br></p>

<p><code>true</code> and <code>false</code> are values of <strong>Boolean</strong> type just like in other programming languages.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">boolean</span><span class="w"> </span><span class="n">false</span><span class="p">)</span><span class="w">
</span><span class="n">false</span><span class="w">

</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">boolean</span><span class="w"> </span><span class="n">nil</span><span class="p">)</span><span class="w">
</span><span class="n">false</span><span class="w">

</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">boolean</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w">
</span><span class="n">true</span><span class="w">

</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">boolean</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w">
</span><span class="n">true</span><span class="w">

</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">boolean</span><span class="w"> </span><span class="s">"hi there"</span><span class="p">)</span><span class="w">
</span><span class="n">true</span><span class="w">

</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">boolean</span><span class="w"> </span><span class="no">:hi</span><span class="p">)</span><span class="w">
</span><span class="n">true</span><span class="w">
</span></code></pre>
<p><br>
<br>
<br>
<br>
<br></p>

<p>In Clojure, everything except <code>false</code> and <code>nil</code> are <code>true</code>.</p>
<h1 id='strings'>Strings</h1><h2 id='literal'>Literal</h2><pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="s">"Hi, there!"</span><span class="w">
</span><span class="s">"Hi, there!"</span><span class="w">
</span></code></pre>
<p></br></p>

<p>You can create a string by double-quoting text.</p>
<h2 id='str'>Str</h2><pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">str</span><span class="w"> </span><span class="s">"Good "</span><span class="w"> </span><span class="s">"morning"</span><span class="p">)</span><span class="w">
</span><span class="s">"Good morning"</span><span class="w">
</span></code></pre>
<p><br></p>

<p>To concatenate strings, use <code>str</code>.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="s">"Good "</span><span class="w"> </span><span class="s">"morning"</span><span class="p">)</span><span class="w">

</span><span class="n">ClassCastException</span><span class="w"> </span><span class="n">java.lang.String</span><span class="w"> </span><span class="n">cannot</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="nb">cast</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">java.lang.Number</span><span class="w">  </span><span class="n">clojure.lang.Numbers.add</span><span class="w"> </span><span class="p">(</span><span class="nf">Numbers.java</span><span class="no">:126</span><span class="p">)</span><span class="w">
</span></code></pre>
<p><br>
<br></p>

<p><code>+</code> operator doesn&#39;t work to concat strings against your expectation.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="nb">first</span><span class="w"> </span><span class="s">"Hirokuni"</span><span class="w">
            </span><span class="nb">last</span><span class="w"> </span><span class="s">"Kim"</span><span class="p">]</span><span class="w">
            </span><span class="p">(</span><span class="nb">str</span><span class="w"> </span><span class="s">"My name is "</span><span class="w"> </span><span class="nb">first</span><span class="w"> </span><span class="s">" "</span><span class="w"> </span><span class="nb">last</span><span class="p">))</span><span class="w">
</span><span class="s">"My name is Hirokuni Kim"</span><span class="w">
</span></code></pre>
<p><br>
<br>
<br>
<br></p>

<p>Clojure doesn&#39;t have string interpolation. <code>str</code> works for you.</p>
<h2 id='format'>Format</h2><pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">format</span><span class="w"> </span><span class="s">"My name is %s %s"</span><span class="w"> </span><span class="s">"Hirokuni"</span><span class="w"> </span><span class="s">"Kim"</span><span class="p">)</span><span class="w">
</span><span class="s">"My name is Hirokuni Kim"</span><span class="w">
</span></code></pre>
<p><br></p>

<p>Like many other languages, Clojure supports string formatting with <code>format</code> function. The concat example above can also be achieved by using <code>format</code> function.</p>

<p><br></p>

<p>The first argument tells <code>format</code> function the format you want to apply to your strings. <code>%s</code> is called format specifier and it specifies the type of data to be formatted. The rest of arguments will replace format specifiers.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">format</span><span class="w"> </span><span class="s">"My favorite fruit is %s"</span><span class="w"> </span><span class="s">"apple"</span><span class="p">)</span><span class="w">
</span><span class="s">"My favorite fruit is apple"</span><span class="w">

</span></code></pre>
<p><br></p>

<p><code>%s</code> is a format specifier for string.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">format</span><span class="w"> </span><span class="s">"I ate %d apples"</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w">
</span><span class="s">"I ate 2 apples"</span><span class="w">
</span></code></pre>
<p><br>
<br>
<br></p>

<p><code>%d</code> is a format specifier for integer.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">format</span><span class="w"> </span><span class="s">"Pi: %.3f"</span><span class="w"> </span><span class="mf">3.14159265</span><span class="p">)</span><span class="w">
</span><span class="s">"Pi: 3.142"</span><span class="w">

</span><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">format</span><span class="w"> </span><span class="s">"Pi: %.5f"</span><span class="w"> </span><span class="mf">3.14159265</span><span class="p">)</span><span class="w">
</span><span class="s">"Pi: 3.14159"</span><span class="w">
</span></code></pre>
<p><br>
<br></p>

<p><code>%.Nf</code> is a format specifier for floating numbers where N specifies how floating points to print.</p>

<p><br></p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">format</span><span class="w"> </span><span class="s">"Boolean representation of 1: %b"</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w">
</span><span class="s">"Boolean representation of 1: true"</span><span class="w">

</span><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">format</span><span class="w"> </span><span class="s">"Boolean representation of nil: %b"</span><span class="w"> </span><span class="n">nil</span><span class="p">)</span><span class="w">
</span><span class="s">"Boolean representation of nil: false"</span><span class="w">
</span></code></pre>
<p><br>
<br>
<br></p>

<p><code>%b</code> is a format specifier for boolean.</p>
<h1 id='integers'>Integers</h1><h2 id='addition'>Addition</h2><pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w">
</span><span class="mi">5</span><span class="w">
</span></code></pre><h2 id='subtraction'>Subtraction</h2><pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w">
</span><span class="mi">7</span><span class="w">
</span></code></pre><h2 id='multiplication'>Multiplication</h2><pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w">
</span><span class="mi">20</span><span class="w">
</span></code></pre><h2 id='division'>Division</h2><pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">/</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w">
</span><span class="mi">2</span><span class="w">
</span></code></pre><pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">/</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w">
</span><span class="mi">4</span><span class="n">/3</span><span class="w">
</span></code></pre>
<p></br>
</br>
</br>
</br>
</br></p>

<p>Interesting thing is that fractions are represented by ratio.</p>
<h2 id='modulo'>Modulo</h2><pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">mod</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w">
</span><span class="mi">1</span><span class="w">
</span></code></pre>
<p><br></p>

<p>Get modulus with <code>mod</code></p>
<h2 id='max'>Max</h2><pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">max</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w">
</span><span class="mi">5</span><span class="w">
</span></code></pre>
<p><br></p>

<p>Get the greatest number with <code>max</code>.</p>
<h2 id='min'>Min</h2><pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">min</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w">
</span><span class="mi">1</span><span class="w">
</span></code></pre>
<p><br></p>

<p>Get the smallest number with <code>min</code>.</p>
<h2 id='power'>Power</h2><pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">power</span><span class="w">
  </span><span class="p">[</span><span class="n">x</span><span class="w"> </span><span class="n">n</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">reduce</span><span class="w"> </span><span class="nb">*</span><span class="w"> </span><span class="p">(</span><span class="nb">repeat</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">x</span><span class="p">))</span><span class="w">
</span><span class="p">)</span><span class="w">

</span><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">power</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w">
</span><span class="mi">8</span><span class="w">
</span></code></pre>
<p>Clojure doesn&#39;t provide built-in function for exponential operation.</p>

<p>Define a function <code>power</code>. <code>reduce</code> takes a sequence generated by <code>repeat</code> and compute <code>*</code> against each element of the sequence and returns the sum. The sum is used to do <code>*</code> against the next element of the sequence.</p>
<h2 id='bigint'>Bigint</h2><pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="p">(</span><span class="nf">bigint</span><span class="w"> </span><span class="n">Long/MAX_VALUE</span><span class="p">)</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w">
</span><span class="mi">9223372036854775817</span><span class="n">N</span><span class="w">
</span></code></pre>
<p><br></p>

<p>You can use <code>bigint</code> to handle really big numbers.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">9223372036854775807</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w">
</span><span class="n">ArithmeticException</span><span class="w"> </span><span class="n">integer</span><span class="w"> </span><span class="n">overflow</span><span class="w">  </span><span class="n">clojure.lang.Numbers.throwIntOverflow</span><span class="w"> </span><span class="p">(</span><span class="nf">Numbers.java</span><span class="no">:1501</span><span class="p">)</span><span class="w">

</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">9223372036854775807</span><span class="n">N</span><span class="w"> </span><span class="mi">10</span><span class="n">N</span><span class="p">)</span><span class="w">
</span><span class="mi">9223372036854775817</span><span class="n">N</span><span class="w">
</span></code></pre>
<p><br>
<br></p>

<p><code>N</code> is a literal for bigint.</p>
<h1 id='lists'>Lists</h1>
<p>Lists are the most basic collection in Clojure which is a dialect of Lisp (List Processing language). However, you don&#39;t often use list as data collection because you have more useful collection data types in Clojure such as vectors or maps.</p>
<h2 id='literal-2'>Literal</h2><pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="o">'</span><span class="p">(</span><span class="nf">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="nf">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w">
</span></code></pre>
<p><br></p>

<p>A list is a simple collection of values. You can create a list by grouping values with parentheses and a single quote <code>&#39;</code> at the beginning.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w">
</span><span class="n">ClassCastException</span><span class="w"> </span><span class="n">java.lang.Long</span><span class="w"> </span><span class="n">cannot</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="nb">cast</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">clojure.lang.IFn</span><span class="w">  </span><span class="n">user/eval2843</span><span class="w"> </span><span class="p">(</span><span class="nf">NO_SOURCE_FILE</span><span class="no">:1</span><span class="p">)</span><span class="w">
</span></code></pre>
<p><br>
<br></p>

<p>We need <code>&#39;</code> to prevent the list from being evaluated.</p>
<h2 id='conj'>Conj</h2><pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">conj</span><span class="w"> </span><span class="o">'</span><span class="p">(</span><span class="nf">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="nf">4</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w">
</span></code></pre>
<p><br></p>

<p>To add a value to the list, use <code>conj</code> (conj[oin]). Note that the new value is added to the top.</p>
<h2 id='how-can-i-remove-elements'>How can I remove elements?</h2>
<p>You may wonder: <em>How can I remove an element at a specific position from a list? How can I remove all elements that match in a list?</em></p>

<p>Unfortunately, there is no built-in function that do these removal operations in lists. You can still use functions from the seq library such as remove, filter, or drop.</p>

<p>If you are not familiar with the seq library, jump to <a href="#sequences">Sequences</a> to learn more!</p>
<h2 id='nth'>Nth</h2><pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">nth</span><span class="w"> </span><span class="o">'</span><span class="p">(</span><span class="nf">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w">
</span><span class="mi">2</span><span class="w">
</span></code></pre>
<p><br></p>

<p>To get a value from the list, use <code>nth</code> with it&#39;s index number. Index starts from 0</p>
<h2 id='count'>Count</h2><pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">count</span><span class="w"> </span><span class="o">'</span><span class="p">(</span><span class="nf">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w">
</span><span class="mi">3</span><span class="w">
</span></code></pre>
<p><br></p>

<p>To count how many values are in a list, use <code>count</code>.</p>
<h1 id='vectors'>Vectors</h1>
<p>You can think of vectors as a more efficient and useful version of lists. It&#39;s more practical to store multiple values in a vector.</p>
<h2 id='literal-3'>Literal</h2><pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="w">
</span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="w">
</span></code></pre>
<p><br></p>

<p>You can create a vector by grouping values with square brackets. Unlike lists, you don&#39;t need <code>&#39;</code> because vectors will not be evaluated.</p>
<h2 id='conj-2'>Conj</h2><pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">conj</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w">
</span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="p">]</span><span class="w">
</span></code></pre>
<p><br></p>

<p>To add a value, use <code>conj</code> (conj[oin]). Note that the new value is added to the end while it is added to the beginning in lists.</p>
<h2 id='how-can-i-remove-elements-2'>How can I remove elements?</h2>
<p>The same story as <a href="#how-can-i-remove-elements?">lists</a>.</p>
<h2 id='nth-2'>Nth</h2><pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">nth</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w">
</span><span class="mi">2</span><span class="w">
</span></code></pre>
<p><br>
To get a value from the vector, you need to specify the index of the value.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">])</span><span class="w">
</span><span class="mi">1</span><span class="w">

</span><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">last</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">])</span><span class="w">
</span><span class="mi">3</span><span class="w">
</span></code></pre>
<p><br>
<br>
<br></p>

<p>Vectors have convenient functions to access elements. To get the first and second elements, use <code>first</code> and <code>second</code>.</p>
<h2 id='indexof'>.indexOf</h2><pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w">  </span><span class="p">(</span><span class="nf">.indexOf</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w">
</span><span class="mi">1</span><span class="w">
</span></code></pre>
<p><br></p>

<p>You can get the index of a value with <code>.indexOf</code>. The dot before indexOf indicates Java interop to access methods in Java.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w">  </span><span class="p">(</span><span class="nf">.indexOf</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w">
</span><span class="mi">-1</span><span class="w">
</span></code></pre>
<p><br>
<br></p>

<p>Returns <code>-1</code> if the value doesn&#39;t exist.</p>
<h1 id='sets'>Sets</h1>
<p>Sets are collections of unique values. In other words, you cannot have duplicated values in a set.</p>

<p>Another important trait of sets is that the order of values is not guaranteed.</p>
<h2 id='literal-4'>Literal</h2><pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="o">#</span><span class="p">{</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w">
</span><span class="o">#</span><span class="p">{</span><span class="mi">1</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">2</span><span class="p">}</span><span class="w">
</span></code></pre>
<p><br></p>

<p>You can create a set by grouping values with <code>#{}</code>. Notice the order of the values is not maintained.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="o">#</span><span class="p">{</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w">
</span><span class="n">IllegalArgumentException</span><span class="w"> </span><span class="n">Duplicate</span><span class="w"> </span><span class="nb">key</span><span class="err">:</span><span class="w"> </span><span class="mi">3</span><span class="w">  </span><span class="n">clojure.lang.PersistentHashSet.createWithCheck</span><span class="w"> </span><span class="p">(</span><span class="nf">PersistentHashSet.java</span><span class="no">:68</span><span class="p">)</span><span class="w">
</span></code></pre>
<p><br>
<br></p>

<p>You will get an exception when you try to store duplicated value. In this case, <code>3</code> is duplicated value.</p>
<h2 id='conj-3'>Conj</h2><pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">conj</span><span class="w"> </span><span class="o">#</span><span class="p">{</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w">
</span><span class="o">#</span><span class="p">{</span><span class="mi">1</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">2</span><span class="p">}</span><span class="w">
</span></code></pre>
<p><br></p>

<p>To add a value, use <code>conj</code> (conj[oin]).</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">conj</span><span class="w"> </span><span class="p">(</span><span class="nb">conj</span><span class="w"> </span><span class="o">#</span><span class="p">{</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w">
</span><span class="o">#</span><span class="p">{</span><span class="mi">1</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">2</span><span class="p">}</span><span class="w">
</span></code></pre>
<p><br>
<br></p>

<p>Because sets doesn&#39;t allow duplicated values, you will see only one <code>4</code> in the final set.</p>
<h2 id='disj'>Disj</h2><pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">disj</span><span class="w"> </span><span class="o">#</span><span class="p">{</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w">
</span><span class="o">#</span><span class="p">{</span><span class="mi">3</span><span class="w"> </span><span class="mi">2</span><span class="p">}</span><span class="w">
</span></code></pre>
<p><br></p>

<p>To create a set where a value is removed (basically removing a value from set), use <code>disj</code> (disj[oin]).</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">disj</span><span class="w"> </span><span class="o">#</span><span class="p">{</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w">
</span><span class="o">#</span><span class="p">{</span><span class="mi">1</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">2</span><span class="p">}</span><span class="w">
</span></code></pre>
<p><br>
<br></p>

<p>If trying to <code>disj</code> a value that doesn&#39;t exist in the set, it returns the original set.</p>
<h2 id='sort'>Sort</h2><pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">sort</span><span class="w"> </span><span class="p">(</span><span class="nb">conj</span><span class="w"> </span><span class="o">#</span><span class="p">{</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w"> </span><span class="mi">4</span><span class="p">))</span><span class="w">
</span><span class="p">(</span><span class="nf">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w">
</span></code></pre>
<p><br></p>

<p>Sets are unordered collections of values, meaning that the order of values is not guaranteed. To get a sorted order, use <code>sort</code>.</p>
<h2 id='contains'>Contains?</h2><pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">contains?</span><span class="w"> </span><span class="o">#</span><span class="p">{</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w">
</span><span class="n">true</span><span class="w">

</span><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">contains?</span><span class="w"> </span><span class="o">#</span><span class="p">{</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w">
</span><span class="n">false</span><span class="w">
</span></code></pre>
<p><br></p>

<p>To check if a value is contained in the set, use <code>contains?</code>.</p>
<h2 id='subset'>Subset?</h2><pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w">  </span><span class="p">(</span><span class="nf">clojure.set/subset?</span><span class="w"> </span><span class="o">#</span><span class="p">{</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="p">}</span><span class="w"> </span><span class="o">#</span><span class="p">{</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="p">})</span><span class="w">
</span><span class="n">true</span><span class="w">

</span><span class="n">user=&gt;</span><span class="w">  </span><span class="p">(</span><span class="nf">clojure.set/subset?</span><span class="w"> </span><span class="o">#</span><span class="p">{</span><span class="mi">1</span><span class="w"> </span><span class="mi">5</span><span class="p">}</span><span class="w"> </span><span class="o">#</span><span class="p">{</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="p">})</span><span class="w">
</span><span class="n">false</span><span class="w">
</span></code></pre>
<p><br></p>

<p>To check if a set is the part of another set, use <code>subset?</code>.</p>
<h2 id='superset'>Superset?</h2><pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w">  </span><span class="p">(</span><span class="nf">clojure.set/superset?</span><span class="w"> </span><span class="o">#</span><span class="p">{</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w"> </span><span class="o">#</span><span class="p">{</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="p">})</span><span class="w">
</span><span class="n">true</span><span class="w">
</span></code></pre>
<p><br></p>

<p>To check if a set includes another set, use <code>superset?</code>.</p>
<h1 id='maps'>Maps</h1>
<p>Maps are key-value data structure to store multiple values.</p>
<h2 id='literal-5'>Literal</h2><pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">{</span><span class="no">:Apple</span><span class="w"> </span><span class="s">"Mac"</span><span class="w"> </span><span class="no">:Microsoft</span><span class="w"> </span><span class="s">"Windows"</span><span class="p">}</span><span class="w">
</span><span class="p">{</span><span class="no">:Apple</span><span class="w"> </span><span class="s">"Mac"</span><span class="n">,</span><span class="w"> </span><span class="no">:Microsoft</span><span class="w"> </span><span class="s">"Windows"</span><span class="p">}</span><span class="w">

</span><span class="n">user=&gt;</span><span class="w"> </span><span class="p">{</span><span class="s">"Apple"</span><span class="w"> </span><span class="s">"Mac"</span><span class="w"> </span><span class="s">"Microsoft"</span><span class="w"> </span><span class="s">"Windows"</span><span class="p">}</span><span class="w">
</span><span class="p">{</span><span class="s">"Apple"</span><span class="w"> </span><span class="s">"Mac"</span><span class="w"> </span><span class="s">"Microsoft"</span><span class="w"> </span><span class="s">"Windows"</span><span class="p">}</span><span class="w">
</span></code></pre>
<p><br></p>

<p>You can create a map by grouping values with <code>{}</code>. Although you can use most of Clojure data type as keys, the two most common type of keys are keyword and string.</p>
<h2 id='get'>Get</h2><pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">get</span><span class="w"> </span><span class="p">{</span><span class="no">:Apple</span><span class="w"> </span><span class="s">"Mac"</span><span class="w"> </span><span class="no">:Microsoft</span><span class="w"> </span><span class="s">"Windows"</span><span class="p">}</span><span class="w"> </span><span class="no">:Apple</span><span class="p">)</span><span class="w">
</span><span class="s">"Mac"</span><span class="w">
</span></code></pre>
<p><br></p>

<p>To get value from key, use <code>get</code>.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w">  </span><span class="p">(</span><span class="nb">get</span><span class="w"> </span><span class="p">{</span><span class="no">:Apple</span><span class="w"> </span><span class="s">"Mac"</span><span class="w"> </span><span class="no">:Microsoft</span><span class="w"> </span><span class="s">"Windows"</span><span class="p">}</span><span class="w"> </span><span class="no">:Linux</span><span class="p">)</span><span class="w">
</span><span class="n">nil</span><span class="w">
</span></code></pre>
<p><br>
<br></p>

<p>You get <code>nil</code> when key doesn&#39;t exist.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w">  </span><span class="p">(</span><span class="nb">get</span><span class="w"> </span><span class="p">{</span><span class="no">:Apple</span><span class="w"> </span><span class="s">"Mac"</span><span class="w"> </span><span class="no">:Microsoft</span><span class="w"> </span><span class="s">"Windows"</span><span class="p">}</span><span class="w"> </span><span class="no">:Linux</span><span class="w"> </span><span class="s">"Sorry, no Linux"</span><span class="p">)</span><span class="w">
</span><span class="n">nil</span><span class="w">
</span></code></pre>
<p><br>
<br></p>

<p>You can specify a default value in the third argument which will be returned when the key doesn&#39;t exist in the map.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="no">:Apple</span><span class="w"> </span><span class="p">{</span><span class="no">:Apple</span><span class="w"> </span><span class="s">"Mac"</span><span class="w"> </span><span class="no">:Microsoft</span><span class="w"> </span><span class="s">"Windows"</span><span class="p">})</span><span class="w">
</span><span class="s">"Mac"</span><span class="w">
</span></code></pre>
<p><br>
<br></p>

<p>When the key of a map is keyword, you can use the keyword just like a function to get the value.</p>
<h2 id='assoc'>Assoc</h2><pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">assoc</span><span class="w"> </span><span class="p">{</span><span class="no">:Apple</span><span class="w"> </span><span class="s">"Mac"</span><span class="w"> </span><span class="no">:Microsoft</span><span class="w"> </span><span class="s">"Windows"</span><span class="p">}</span><span class="w"> </span><span class="no">:Commodore</span><span class="w"> </span><span class="s">"Amiga"</span><span class="p">)</span><span class="w">
</span><span class="p">{</span><span class="no">:Commodore</span><span class="w"> </span><span class="s">"Amiga"</span><span class="w"> </span><span class="no">:Apple</span><span class="w"> </span><span class="s">"Mac"</span><span class="w"> </span><span class="no">:Microsoft</span><span class="w"> </span><span class="s">"Windows"</span><span class="p">}</span><span class="w">
</span></code></pre>
<p><br></p>

<p>To add a key-value pair, use <code>assoc</code>.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">assoc</span><span class="w"> </span><span class="p">{</span><span class="no">:Apple</span><span class="w"> </span><span class="s">"Mac"</span><span class="w"> </span><span class="no">:Microsoft</span><span class="w"> </span><span class="s">"Windows"</span><span class="p">}</span><span class="w"> </span><span class="no">:Apple</span><span class="w"> </span><span class="s">"iOS"</span><span class="p">)</span><span class="w">
</span><span class="p">{</span><span class="no">:Apple</span><span class="w"> </span><span class="s">"iOS"</span><span class="w"> </span><span class="no">:Microsoft</span><span class="w"> </span><span class="s">"Windows"</span><span class="p">}</span><span class="w">
</span></code></pre>
<p><br>
<br></p>

<p>If the key already exists, it replaces the value.</p>
<h2 id='merge'>Merge</h2><pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">merge</span><span class="w"> </span><span class="p">{</span><span class="no">:Apple</span><span class="w"> </span><span class="s">"Mac"</span><span class="w"> </span><span class="no">:Microsoft</span><span class="w"> </span><span class="s">"Windows"</span><span class="p">}</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="p">})</span><span class="w">
</span><span class="p">{</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="n">,</span><span class="w"> </span><span class="no">:Apple</span><span class="w"> </span><span class="s">"Mac"</span><span class="w"> </span><span class="no">:Microsoft</span><span class="w"> </span><span class="s">"Windows"</span><span class="p">}</span><span class="w">
</span></code></pre>
<p><br></p>

<p>To combine two maps, use <code>merge</code>.</p>
<h2 id='keys'>Keys</h2><pre class="highlight clojure tab-clojure"><code><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">keys</span><span class="w"> </span><span class="p">{</span><span class="no">:Apple</span><span class="w"> </span><span class="s">"Mac"</span><span class="w"> </span><span class="no">:Microsoft</span><span class="w"> </span><span class="s">"Windows"</span><span class="p">})</span><span class="w">
</span><span class="p">(</span><span class="no">:Apple</span><span class="w"> </span><span class="no">:Microsoft</span><span class="p">)</span><span class="w">
</span></code></pre>
<p><br></p>

<p>To get all keys from a map, use <code>keys</code>.</p>
<h2 id='vals'>Vals</h2><pre class="highlight clojure tab-clojure"><code><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">vals</span><span class="w"> </span><span class="p">{</span><span class="no">:Apple</span><span class="w"> </span><span class="s">"Mac"</span><span class="w"> </span><span class="no">:Microsoft</span><span class="w"> </span><span class="s">"Windows"</span><span class="p">})</span><span class="w">
</span><span class="p">(</span><span class="s">"Mac"</span><span class="w"> </span><span class="s">"Windows"</span><span class="p">)</span><span class="w">
</span></code></pre>
<p><br></p>

<p>To get all values from a map, use <code>vals</code>.</p>
<h1 id='sequences'>Sequences</h1>
<p>Sequences are data types that store multiple values. You may wonder: <em>What are differences from lists or vectors? Why Clojure has so many different collection data types?!</em></p>

<p>Yes, you can use lists and vectors to store multiple values. In fact, lists and vectors are sequences, and other collection data types such as maps or sets are also sequences.</p>

<p>Sequences are data types that abstract all more concrete data types with unified functions. These functions are called the <strong>Seq library</strong> in Clojure.</p>

<p>One virtue of the sequence is that you can call the same function to collections without worrying about what types of collections that you are dealing with.</p>

<p>Let&#39;s take a look at examples of using <code>map</code> to different types of collections.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="nb">inc</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="p">])</span><span class="w">
</span><span class="p">(</span><span class="nf">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w">

</span><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="nb">inc</span><span class="w"> </span><span class="o">`</span><span class="p">(</span><span class="w"> </span><span class="nf">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="p">))</span><span class="w">
</span><span class="p">(</span><span class="nf">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w">

</span><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="nb">inc</span><span class="w"> </span><span class="o">#</span><span class="p">{</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="p">})</span><span class="w">
</span><span class="p">(</span><span class="nf">2</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w">



</span><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="nb">key</span><span class="w"> </span><span class="p">{</span><span class="no">:a</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="no">:c</span><span class="w"> </span><span class="mi">3</span><span class="p">})</span><span class="w">
</span><span class="p">(</span><span class="no">:a</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="no">:c</span><span class="p">)</span><span class="w">
</span></code></pre>
<p><br></p>

<p>Applying <code>map</code> for the vector.</p>

<p><br></p>

<p>Applying <code>map</code> for the list.</p>

<p><br></p>

<p>Applying map for the set.</p>

<p><br></p>

<p>Applying <code>map</code> for the map. We are using <code>key</code> function in this case because <code>inc</code> doesn&#39;t work with the map.</p>

<p>When you can apply functions of the seq library to a data type, we say the data type is <strong>seqable</strong>. The examples above work because lists, vectors, sets, and maps are all seqable collections.</p>

<p><br>
<br></p>

<p>We will see more functions in the seq library in the following sections to get familiar with sequences.</p>
<h2 id='seq'>Seq</h2>
<p>To construct a sequence, use <code>seq</code>.</p>

<p><code>seq</code> takes one seqable collection and converts to a sequence.</p>

<p>The collection data types such as lists, vectors, sets, and maps are all seqable, therefore you can pass any of them to <code>seq</code>.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">seq</span><span class="w"> </span><span class="o">'</span><span class="p">(</span><span class="nf">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">))</span><span class="w">
</span><span class="p">(</span><span class="nf">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w">
</span></code></pre>
<p><br></p>

<p>Converting a list to a sequence.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">seq</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">])</span><span class="w">
</span><span class="p">(</span><span class="nf">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w">
</span></code></pre>
<p><br>
<br></p>

<p>Converting a vector to a sequence.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">seq</span><span class="w"> </span><span class="o">#</span><span class="p">{</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">})</span><span class="w">
</span><span class="p">(</span><span class="nf">1</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w">
</span></code></pre>
<p><br>
<br></p>

<p>Converting a set to a sequence.</p>
<pre class="highlight plaintext"><code>user=&gt; (seq {:a 1 :b 2 :c 3})
([:a 1] [:b 2] [:c 3])
</code></pre>
<p><br>
<br></p>

<p>Converting a map to a sequence.</p>

<p><br></p>

<p><strong>Seqable data types and <code>seq</code> are what make sequences elegant in Clojure.</strong> As long as your data types are seqable, <code>seq</code> will convert the data to a sequence.
This is why you can apply the same functions in the seq library to different collection types transparently. These seq library functions internally convert passed collection to a sequence and do the right things for you.</p>

<p><br></p>

<p>You may wonder that returned values look like lists in REPL. However, this is just a matter of displaying and they are actually sequences.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">type</span><span class="w"> </span><span class="p">(</span><span class="nb">seq</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">]))</span><span class="w">
</span><span class="n">clojure.lang.PersistentVector$ChunkedSeq</span><span class="w">
</span></code></pre>
<p><br></p>

<p>It&#39;s clear that it&#39;s a sequence if you use <code>type</code>.</p>
<h2 id='first'>First</h2>
<p>To get the first element from a sequence, use <code>first</code>.</p>

<p>You probably have used <code>first</code> with different collection data types before without knowing <code>first</code> is actually a sequence function.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">])</span><span class="w">
</span><span class="mi">1</span><span class="w">
</span></code></pre>
<p><br></p>

<p>Getting the first element in the vector.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="s">"string"</span><span class="p">)</span><span class="w">
</span><span class="sc">\s</span><span class="w">
</span></code></pre>
<p><br>
<br></p>

<p>Getting the first element in the vector.</p>

<p><br>
<br></p>

<p>You can call <code>first</code> with any collection data types (string is a collection of characters) and get expected behavior because <code>first</code> is a sequence function and all of these data types are seqable.</p>
<h2 id='rest'>Rest</h2><pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">])</span><span class="w">
</span><span class="p">(</span><span class="nf">2</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w">
</span></code></pre>
<p>To get all elements except the first one from a sequence, use <code>rest</code>.</p>

<p><br>
<br></p>

<p>Here we can see another important trait of sequences: sequence function always returns a sequence no matter of what types of collection it takes.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">type</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">])</span><span class="w">
</span><span class="n">clojure.lang.PersistentVector</span><span class="w">

</span><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">type</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">]))</span><span class="w">
</span><span class="n">clojure.lang.PersistentVector$ChunkedSeq</span><span class="w">
</span></code></pre>
<p><br></p>

<p><code>type</code> tells you the type of data. As you can see, the vector becomes sequence (<em>CheckedSeq is a type of sequence</em>) once it goes through <code>rest</code> function.</p>
<h2 id='cons'>Cons</h2><pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">'</span><span class="p">(</span><span class="nf">1</span><span class="w"> </span><span class="mi">2</span><span class="p">))</span><span class="w">
</span><span class="p">(</span><span class="nf">0</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w">
</span></code></pre>
<p><br></p>

<p>To add an element to the head of sequence, use <code>cons</code>.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">old-seq</span><span class="w"> </span><span class="o">'</span><span class="p">(</span><span class="nf">1</span><span class="w"> </span><span class="mi">2</span><span class="p">))</span><span class="w">
</span><span class="o">#</span><span class="ss">'user/old-seq</span><span class="w">

</span><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">new-seq</span><span class="w"> </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">old-seq</span><span class="p">))</span><span class="w">
</span><span class="o">#</span><span class="ss">'user/new-seq</span><span class="w">

</span><span class="n">user=&gt;</span><span class="w"> </span><span class="n">old-seq</span><span class="w">
</span><span class="p">(</span><span class="nf">1</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w">

</span><span class="n">user=&gt;</span><span class="w"> </span><span class="n">new-seq</span><span class="w">
</span><span class="p">(</span><span class="nf">0</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w">
</span></code></pre>
<p><br>
<br></p>

<p>The operation is equivalent to construct a new sequence by adding an element to the existing sequence, therefore <code>cons</code>(cons[truct]).</p>
<h2 id='concat'>Concat</h2><pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">concat</span><span class="w"> </span><span class="o">'</span><span class="p">(</span><span class="nf">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="o">'</span><span class="p">(</span><span class="nf">4</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="mi">6</span><span class="p">))</span><span class="w">
</span><span class="p">(</span><span class="nf">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="mi">6</span><span class="p">)</span><span class="w">
</span></code></pre>
<p><br></p>

<p>To combine sequences, use <code>concat</code>.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">concat</span><span class="w"> </span><span class="o">'</span><span class="p">(</span><span class="nf">1</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">'</span><span class="p">(</span><span class="nf">4</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w"> </span><span class="o">'</span><span class="p">(</span><span class="nf">7</span><span class="w"> </span><span class="mi">8</span><span class="p">)</span><span class="w"> </span><span class="o">'</span><span class="p">(</span><span class="nf">9</span><span class="w"> </span><span class="mi">10</span><span class="p">))</span><span class="w">
</span><span class="p">(</span><span class="nf">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="mi">9</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w">
</span></code></pre>
<p><br>
<br></p>

<p>You can also pass more than two sequences to <code>concat</code>.</p>
<h2 id='map'>Map</h2><pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="nb">inc</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="p">])</span><span class="w">
</span><span class="p">(</span><span class="nf">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w">
</span></code></pre>
<p><br></p>

<p>To apply a function to each element of a sequence, use <code>map</code>.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">inc</span><span class="w"> </span><span class="p">(</span><span class="nb">val</span><span class="w"> </span><span class="n">x</span><span class="p">)))</span><span class="w"> </span><span class="p">{</span><span class="no">:a</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="no">:c</span><span class="w"> </span><span class="mi">3</span><span class="p">})</span><span class="w">
</span><span class="p">(</span><span class="nf">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w">
</span></code></pre>
<p><br>
<br></p>

<p>If you want to do something more complex with each element, you can pass an anonymous function where each value is bound to <code>x</code>.</p>
<h2 id='reduce'>Reduce</h2><pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">reduce</span><span class="w"> </span><span class="nb">+</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="p">])</span><span class="w">
</span><span class="mi">10</span><span class="w">
</span></code></pre>
<p><br></p>

<p><code>reduce</code> boils down elements in a sequence into a single value by applying a function.</p>

<p><br></p>

<p>The way <code>reduce</code> works is that it first takes out the first two elements from the sequence and apply the function to get a result. Then applying the same function to the result with the third element and keeps doing the same until the end of the sequence. Because of this nature, the function must take two arguments.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">reduce</span><span class="w"> </span><span class="nb">inc</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="p">])</span><span class="w">
</span><span class="n">ArityException</span><span class="w"> </span><span class="n">Wrong</span><span class="w"> </span><span class="n">number</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">args</span><span class="w"> </span><span class="p">(</span><span class="nf">2</span><span class="p">)</span><span class="w"> </span><span class="n">passed</span><span class="w"> </span><span class="n">to</span><span class="err">:</span><span class="w"> </span><span class="n">core/inc</span><span class="w">  </span><span class="n">clojure.lang.AFn.throwArity</span><span class="w"> </span><span class="p">(</span><span class="nf">AFn.java</span><span class="no">:429</span><span class="p">)</span><span class="w">
</span></code></pre>
<p><br></p>

<p>Otherwise, you will get an exception (<code>inc</code> is an one argument function)</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">reduce</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">res</span><span class="w"> </span><span class="nb">val</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">res</span><span class="w"> </span><span class="nb">val</span><span class="p">))</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="p">])</span><span class="w">
</span><span class="mi">10</span><span class="w">
</span></code></pre>
<p><br>
<br></p>

<p>Of course, you can pass an anonymous function to do more complex stuff. Just don&#39;t don&#39;t forget that the anonymous function must take two arguments.</p>

<p><br>
<br></p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">reduce</span><span class="w"> </span><span class="nb">+</span><span class="w"> </span><span class="mi">-10</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="p">])</span><span class="w">
</span><span class="mi">0</span><span class="w">
</span></code></pre>
<p><br></p>

<p>If you don&#39;t want to start with the first element of the sequence, you can pass a starting point in the second argument.</p>
<h2 id='into'>Into</h2>
<p>To insert all elements of a sequence into another sequence, use <code>into</code>.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">into</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">`</span><span class="p">(</span><span class="nf">4</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="mi">6</span><span class="p">))</span><span class="w">
</span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="mi">6</span><span class="p">]</span><span class="w">
</span></code></pre>
<p><br></p>

<p>Inserting all elements of the list into the vector.</p>

<p><br></p>

<p>Because of the nature, <code>into</code> is frequently used to convert from one collection type to another.</p>
<pre class="highlight clojure tab-clojure"><code><span class="w">
</span><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">into</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="o">`</span><span class="p">(</span><span class="nf">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">))</span><span class="w">
</span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="w">
</span></code></pre>
<p><br>
<br></p>

<p>Converting a list to a vector.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">into</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="p">)</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">])</span><span class="w">
</span><span class="p">(</span><span class="nf">3</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w">
</span></code></pre>
<p><br>
<br></p>

<p>Converting a vector to a list.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">into</span><span class="w"> </span><span class="o">#</span><span class="p">{}</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">])</span><span class="w">
</span><span class="o">#</span><span class="p">{</span><span class="mi">1</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">2</span><span class="p">}</span><span class="w">
</span></code></pre>
<p><br>
<br></p>

<p>Converting a vector to a set.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">into</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="o">#</span><span class="p">{</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">})</span><span class="w">
</span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="w">
</span></code></pre>
<p><br>
<br></p>

<p>Converting a set to a vector.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">into</span><span class="w"> </span><span class="p">{}</span><span class="w"> </span><span class="p">[[</span><span class="no">:a</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="p">[</span><span class="no">:b</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="p">[</span><span class="no">:c</span><span class="w"> </span><span class="mi">3</span><span class="p">]])</span><span class="w">
</span><span class="p">{</span><span class="no">:a</span><span class="w"> </span><span class="mi">1</span><span class="n">,</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="mi">2</span><span class="n">,</span><span class="w"> </span><span class="no">:c</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w">
</span></code></pre>
<p><br>
<br></p>

<p>Converting a nested vector into a map.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">into</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="p">{</span><span class="no">:a</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="no">:c</span><span class="w"> </span><span class="mi">3</span><span class="p">})</span><span class="w">
</span><span class="p">[[</span><span class="no">:c</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="p">[</span><span class="no">:b</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="p">[</span><span class="no">:a</span><span class="w"> </span><span class="mi">1</span><span class="p">]]</span><span class="w">
</span></code></pre>
<p><br>
<br></p>

<p>Converting a map to a nested vector.</p>
<h2 id='reverse'>Reverse</h2><pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">reverse</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">])</span><span class="w">
</span><span class="p">(</span><span class="nf">3</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w">
</span></code></pre>
<p><br></p>

<p>To reverse a sequence, use <code>reverse</code>.</p>
<h2 id='iterate'>Iterate</h2><pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">iterate</span><span class="w"> </span><span class="nb">+</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w">

</span></code></pre>
<p><br></p>

<p>You can get a sequence of infinite integers with <code>iterate</code>. Be careful, though. Running this example will freeze your terminal since the evaluation of this expression never returns.</p>
<h2 id='range'>Range</h2><pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">range</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="nf">5</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="mi">9</span><span class="p">)</span><span class="w">
</span></code></pre>
<p><br></p>

<p>To generates a sequence of numbers between two points, use <code>range</code>.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">range</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="mi">100</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="nf">0</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="mi">15</span><span class="w"> </span><span class="mi">20</span><span class="w"> </span><span class="mi">25</span><span class="w"> </span><span class="mi">30</span><span class="w"> </span><span class="mi">35</span><span class="w"> </span><span class="mi">40</span><span class="w"> </span><span class="mi">45</span><span class="w"> </span><span class="mi">50</span><span class="w"> </span><span class="mi">55</span><span class="w"> </span><span class="mi">60</span><span class="w"> </span><span class="mi">65</span><span class="w"> </span><span class="mi">70</span><span class="w"> </span><span class="mi">75</span><span class="w"> </span><span class="mi">80</span><span class="w"> </span><span class="mi">85</span><span class="w"> </span><span class="mi">90</span><span class="w"> </span><span class="mi">95</span><span class="p">)</span><span class="w">
</span></code></pre>
<p><br>
<br></p>

<p>You can get integers by every x within the range. In this case, we get a sequence of integers at every 5.</p>
<h2 id='repeatedly'>Repeatedly</h2><pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">repeatedly</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"hi!"</span><span class="p">))</span><span class="w"> </span><span class="p">)</span><span class="w">
</span><span class="n">hi!</span><span class="w">
</span><span class="n">hi!</span><span class="w">
</span><span class="n">hi!</span><span class="w">
</span><span class="n">hi!</span><span class="w">
</span><span class="n">hi!</span><span class="w">
</span><span class="p">(</span><span class="nf">nil</span><span class="w"> </span><span class="n">nil</span><span class="w"> </span><span class="n">nil</span><span class="w"> </span><span class="n">nil</span><span class="w"> </span><span class="n">nil</span><span class="p">)</span><span class="w">
</span></code></pre>
<p><br></p>

<p>To repeat something over and over again, use <code>repeatedly</code>. We are passing an anonymous function <code>(fn [] (println &quot;hi!&quot;))</code> because the second argument must be a function.</p>
<h2 id='doseq'>Doseq</h2><pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">doseq</span><span class="w"> </span><span class="p">[</span><span class="n">animal</span><span class="w"> </span><span class="p">[</span><span class="s">"cat"</span><span class="w"> </span><span class="s">"dog"</span><span class="w"> </span><span class="s">"horse"</span><span class="p">]]</span><span class="w"> </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="n">animal</span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w">
</span><span class="n">cat</span><span class="w">
</span><span class="n">dog</span><span class="w">
</span><span class="n">horse</span><span class="w">
</span><span class="n">nil</span><span class="w">
</span></code></pre>
<p><br></p>

<p>Clojure doesn&#39;t have <code>for</code> or <code>for-each</code>. Do something to each element of a sequence, use <code>doseq</code>.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">doseq</span><span class="w"> </span><span class="p">[</span><span class="n">n1</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">]</span><span class="w">
               </span><span class="n">n2</span><span class="w"> </span><span class="p">[</span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="p">]]</span><span class="w">
         </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">n1</span><span class="w"> </span><span class="n">n2</span><span class="p">)))</span><span class="w">
</span><span class="mi">5</span><span class="w">
</span><span class="mi">6</span><span class="w">
</span><span class="mi">6</span><span class="w">
</span><span class="mi">7</span><span class="w">
</span><span class="n">nil</span><span class="w">
</span></code></pre>
<p><br>
<br>
<br>
<br>
<br></p>

<p>You can bind multiple values. In this case, each element in the first vector is added to each element of the second vector.</p>
<h2 id='take'>Take</h2><pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">take</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="p">(</span><span class="nb">range</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="mi">100</span><span class="p">))</span><span class="w">
</span><span class="p">(</span><span class="nf">0</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w">
</span></code></pre>
<p><br></p>

<p>To get the first <code>n</code> elements from a sequence, use <code>take</code>.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w">  </span><span class="p">(</span><span class="nb">take</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="p">(</span><span class="nb">range</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="mi">5</span><span class="p">))</span><span class="w">
</span><span class="p">(</span><span class="nf">0</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w">
</span></code></pre>
<p><br>
<br></p>

<p>Take all elements from a sequence if the size of the sequence is smaller than <code>n</code>.</p>
<h2 id='take-while'>Take-While</h2>
<p><br></p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">take-while</span><span class="w"> </span><span class="nb">neg?</span><span class="w"> </span><span class="p">[</span><span class="mi">-3</span><span class="w"> </span><span class="mi">-2</span><span class="w"> </span><span class="mi">-1</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">])</span><span class="w">
</span><span class="p">(</span><span class="nf">-3</span><span class="w"> </span><span class="mi">-2</span><span class="w"> </span><span class="mi">-1</span><span class="p">)</span><span class="w">
</span></code></pre>
<p>To get the first <code>n</code> elements from a sequence as long as the condition is satisfied but stop taking when the condition is not met, use <code>take-while</code>. <code>neg?</code> returns true for negative number.</p>

<p><strong>Note:</strong> Taking elements that only satisfies the condition is not what <code>take-while</code> does. That&#39;s the job of <code>select</code>.</p>
<h2 id='drop'>Drop</h2><pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">drop</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="p">(</span><span class="nb">range</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="mi">10</span><span class="p">))</span><span class="w">
</span><span class="p">(</span><span class="nf">5</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="mi">9</span><span class="p">)</span><span class="w">
</span></code></pre>
<p><br></p>

<p><code>drop</code> is probably the most primitive way to remove elements from a sequence. <code>drop</code> will remove the first <code>n</code> elements.</p>
<h2 id='drop-while'>Drop-While</h2><pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">drop-while</span><span class="w"> </span><span class="nb">neg?</span><span class="w"> </span><span class="p">[</span><span class="mi">-3</span><span class="w"> </span><span class="mi">-2</span><span class="w"> </span><span class="mi">-1</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">])</span><span class="w">
</span><span class="p">(</span><span class="nf">0</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w">
</span></code></pre>
<p><br></p>

<p>To get the first <code>n</code> elements from a sequence as long as the condition is satisfied but stop dropping when the condition is not met, use <code>drop-while</code>.</p>
<h2 id='filter'>Filter</h2>
<p>You can remove elements that match the rule you specify from a sequence with <code>filter</code>.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">filter</span><span class="w"> </span><span class="nb">pos?</span><span class="w"> </span><span class="p">[</span><span class="mi">-1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">])</span><span class="w">
</span><span class="p">(</span><span class="nf">2</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w">
</span></code></pre>
<p><br></p>

<p>Here is an example to remove positive numbers from a sequence. In this case, being a positive number is the rule that you specify.</p>

<p>The rule is called <strong>predicate</strong>. Predicates are functions that return boolean values such as <code>pos?</code>.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">filter</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="mi">2</span><span class="p">))</span><span class="w"> </span><span class="p">[</span><span class="mi">-1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">])</span><span class="w">
</span><span class="p">(</span><span class="nf">2</span><span class="p">)</span><span class="w">
</span></code></pre>
<p><br></p>

<p>You can construct your own predicate with <a href="#anonymous-function">anonymous functions</a>. In this example, we are removing elements that are <code>2</code>.</p>
<h2 id='remove'>Remove</h2>
<p>You can remove elements that matches a predicate with <code>remove</code>. The difference from <code>filter</code> is that returned value is what&#39;s removed.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">remove</span><span class="w"> </span><span class="nb">pos?</span><span class="w"> </span><span class="p">[</span><span class="mi">-1</span><span class="w"> </span><span class="mi">-2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="p">])</span><span class="w">
</span><span class="p">(</span><span class="nf">-1</span><span class="w"> </span><span class="mi">-2</span><span class="p">)</span><span class="w">
</span></code></pre>
<p><br></p>

<p>In this example, we remove positive numbers from a sequence. The returned values are negative numbers.</p>
<h2 id='partition-by'>Partition-by</h2><pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">partition-by</span><span class="w"> </span><span class="o">#</span><span class="p">(</span><span class="nb">&lt;</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="n">%</span><span class="p">)</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="mi">6</span><span class="p">])</span><span class="w">
</span><span class="p">((</span><span class="nf">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">4</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="mi">6</span><span class="p">))</span><span class="w">
</span></code></pre>
<p><br></p>

<p>To split a collection and group together in a certain way, or in other word partition, use <code>partition</code>. In this example, we partition the vector into two groups: one smaller than or equal 3 and another bigger than 3.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">partition-by</span><span class="w"> </span><span class="o">#</span><span class="p">(</span><span class="nb">&lt;</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="n">%</span><span class="p">)</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">])</span><span class="w">
</span><span class="p">((</span><span class="nf">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">4</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="mi">6</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">))</span><span class="w">
</span></code></pre>
<p><br></p>

<p>Notice that <code>(1 2 3)</code> at the end of the sequence is grouped together as a separate sequence from the first one. <code>partition-by</code> doesn&#39;t merge values.</p>
<h2 id='group-by'>Group-by</h2><pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">group-by</span><span class="w"> </span><span class="o">#</span><span class="p">(</span><span class="nb">&lt;</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="n">%</span><span class="p">)</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">])</span><span class="w">
</span><span class="p">{</span><span class="n">false</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="n">,</span><span class="w"> </span><span class="n">true</span><span class="w"> </span><span class="p">[</span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="mi">6</span><span class="p">]}</span><span class="w">
</span></code></pre>
<p><code>group-by</code> splits a collection and does merge them together unlike <code>partition-by</code>. <code>group-by</code> returns a map where key is the result of the grouping condition.</p>
<h2 id='lazy-sequence'>Lazy Sequence</h2>
<p>Most of Clojure&#39;s sequences are <strong>lazy</strong>. All familiar functions such as <code>map</code> <code>range</code> <code>reduce</code> etc returns lazy sequences.</p>
<pre class="highlight clojure tab-clojure"><code><span class="c1">;; You need hit Ctrl+c very quickly to stop!!</span><span class="w">
</span><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="p">(</span><span class="nb">iterate</span><span class="w"> </span><span class="nb">inc</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span><span class="w">
</span><span class="p">(</span><span class="nf">0</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="n">......</span><span class="w">
</span></code></pre>
<p><br></p>

<p><code>(iterate inc 0)</code> generates a sequence of infinite numbers which, of course, takes infinitely. But, you see <code>println</code> starts printing the numbers <code>(0 1 2 3 ......</code>. If the generation of the sequence never ends, how <code>println</code> can even start printing these numbers?</p>

<p><br></p>

<p>This is possible because <code>iterate</code> generates lazy sequence and <code>println</code> is able to handle lazy sequence correctly. <code>println</code> asks a number to print from <code>iterate</code> one by one, rather than asking the entire sequence. <code>iterate</code> only computes numbers as it is requested and pass the numbers to <code>println</code>.</p>
<pre class="highlight clojure tab-clojure"><code><span class="w">

</span><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="p">(</span><span class="nb">take</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="p">(</span><span class="nb">iterate</span><span class="w"> </span><span class="nb">inc</span><span class="w"> </span><span class="mi">0</span><span class="p">)))</span><span class="w">
</span><span class="p">(</span><span class="nf">0</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w">
</span><span class="n">nil</span><span class="w">
</span></code></pre>
<p><br>
<br></p>

<p><code>take</code> only asks the first <code>n</code> values from lazy sequence. <code>iterate</code> also only computes the first five numbers because that&#39;s what asked by <code>take</code>.</p>

<p><br></p>
<h2 id='for'>For</h2>
<p>If you are looking for how to write a loop in Clojure, I&#39;m sorry, but this is not what you are looking for. Clojure doesn&#39;t have an imperative loop because there is no mutable local variable in Clojure. Please see the <a href="#loop">loop</a> section for more information.</p>

<p>In Clojure, <code>for</code> is <strong>list comprehension</strong>. What is list comprehension? First of all, let&#39;s look at an example.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">for</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="w"> </span><span class="o">'</span><span class="p">(</span><span class="nf">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">)]</span><span class="w">
         </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="n">x</span><span class="p">))</span><span class="w">
</span><span class="p">(</span><span class="nf">11</span><span class="w"> </span><span class="mi">12</span><span class="w"> </span><span class="mi">13</span><span class="p">)</span><span class="w">

</span></code></pre>
<p><br></p>

<p><code>for</code> takes a vector of one or more collections and iterate over collections while binding each value to symbols.</p>

<p><br></p>

<p>In short, <strong>list comprehension</strong> is a way to create a list from existing lists. The idea of list comprehension comes from the world of math. It&#39;s used in order to write sets in simpler and easier way.</p>

<p>For example, <code>{x | x &gt;0}</code> means the set of all <code>x</code> that is bigger than than 0. So if <code>x</code> is the set of -1, 1, and 2, then the notation refers to the set of 1 and 2 but not -1.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">for</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="w"> </span><span class="o">'</span><span class="p">(</span><span class="nf">-1</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="no">:when</span><span class="w"> </span><span class="p">(</span><span class="nb">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">x</span><span class="p">)]</span><span class="w">
         </span><span class="n">x</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="nf">1</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w">
</span></code></pre>
<p><br></p>

<p>This is a list comprehension that means the same thing as <code>{x | x &gt;0}</code> in math.</p>

<p><code>:when</code> modifier evaluates the body only for values where the predicate is true.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">for</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="p">]</span><span class="w">
             </span><span class="no">:let</span><span class="w"> </span><span class="p">[</span><span class="n">y</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="mi">3</span><span class="p">)]</span><span class="w">
             </span><span class="no">:when</span><span class="w"> </span><span class="p">(</span><span class="nf">even?</span><span class="w"> </span><span class="n">y</span><span class="p">)]</span><span class="w">
         </span><span class="n">y</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="nf">0</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="mi">12</span><span class="p">)</span><span class="w">
</span></code></pre>
<p><br></p>

<p><code>let</code> modifier can be used to bind intermediate values.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">for</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="w"> </span><span class="p">(</span><span class="nb">range</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="no">:while</span><span class="w"> </span><span class="p">(</span><span class="nb">not=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="mi">5</span><span class="p">)]</span><span class="w">
         </span><span class="n">x</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="nf">0</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w">
</span></code></pre>
<p><br>
<br>
<br>
<br>
<br></p>

<p><code>while</code> modifier stops the evaluation of the body when the predicate is false.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">for</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="w"> </span><span class="p">[</span><span class="ss">'a</span><span class="w"> </span><span class="ss">'b</span><span class="w"> </span><span class="ss">'c</span><span class="p">]</span><span class="w">
             </span><span class="n">y</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">]]</span><span class="w">
        </span><span class="p">[</span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="p">])</span><span class="w">
</span><span class="p">([</span><span class="n">a</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="p">[</span><span class="n">b</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="p">[</span><span class="n">b</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="p">[</span><span class="n">b</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="p">[</span><span class="n">c</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="p">[</span><span class="n">c</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="p">[</span><span class="n">c</span><span class="w"> </span><span class="mi">3</span><span class="p">])</span><span class="w">
</span></code></pre>
<p><br>
<br>
<br></p>

<p><code>for</code> iterates collections in a nested fashion. It&#39;s useful to create a combination of all elements in given collections.</p>
<h1 id='recursion'>Recursion</h1>
<p>Function is recursive when the function calls itself inside it&#39;s definition. This is the most simple way of doing recursion.</p>

<p>We will start from the example of <code>fibo-recursive</code> function that computes Nth Fibonacci number in the Fibonacci sequence because writing function that computes the Fibonacci numbers is a recursive programming version of hello world.</p>

<p>The Fibonacci sequence is consisted of numbers characterized by the fact that every number after the first two is the sum of the two preceding ones. <code>0 1 1 2 3 5 8 13 ....</code> are the beginning of the sequence.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">fibo-recursive</span><span class="w"> </span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="w">
         </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">or</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span><span class="w">
           </span><span class="n">n</span><span class="w">
           </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="p">(</span><span class="nf">fibo-recursive</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="nf">fibo-recursive</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="mi">2</span><span class="p">)))))</span><span class="w">

</span><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">fibo-recursive</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w">
</span><span class="mi">0</span><span class="w">

</span><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">fibo-recursive</span><span class="w"> </span><span class="mi">6</span><span class="p">)</span><span class="w">
</span><span class="mi">8</span><span class="w">
</span></code></pre>
<p><br></p>

<p>As you can see, we are calling <code>fibo-recursive</code> function inside the function body of <code>fibo-recursive</code> function. Calling the function inside the function body is the most basic way to do recursive programming in Clojure and many other programming languages.</p>
<h2 id='recur'>Recur</h2>
<p>The simple recursion, calling itself inside it&#39;s definition, is not the only way to make recursive function in Clojure. <code>recur</code> is a handy tool to do recursion.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">fibo-recur</span><span class="w"> </span><span class="p">[</span><span class="n">iteration</span><span class="p">]</span><span class="w">
        </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">fibo</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">one</span><span class="w"> </span><span class="n">two</span><span class="w"> </span><span class="n">n</span><span class="p">]</span><span class="w">
          </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="n">iteration</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w">
            </span><span class="n">one</span><span class="w">
            </span><span class="p">(</span><span class="nf">recur</span><span class="w"> </span><span class="n">two</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">one</span><span class="w"> </span><span class="n">two</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">inc</span><span class="w"> </span><span class="n">n</span><span class="p">))))]</span><span class="w">
          </span><span class="c1">;; 0N 1N are bigint literals. See Bigint section</span><span class="w">
          </span><span class="c1">;; We need to use bigint to avoid StackOverflow to do the addition of big Fibonacci numbers</span><span class="w">
          </span><span class="c1">;; demonstrated below.</span><span class="w">
          </span><span class="p">(</span><span class="nf">fibo</span><span class="w"> </span><span class="mi">0</span><span class="n">N</span><span class="w"> </span><span class="mi">1</span><span class="n">N</span><span class="w"> </span><span class="mi">0</span><span class="p">)))</span><span class="w">

</span><span class="o">#</span><span class="ss">'user/fibo-recur</span><span class="w">

</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">fibo-recur</span><span class="w"> </span><span class="mi">6</span><span class="p">)</span><span class="w">
</span><span class="mi">8</span><span class="w">
</span></code></pre>
<p><br></p>

<p>We can write a Fibonacci function by using <code>recur</code> as well. <code>recur</code> re-binds it&#39;s arguments to new values and call the function with the new values.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">count-down</span><span class="w"> </span><span class="p">[</span><span class="n">result</span><span class="w"> </span><span class="n">n</span><span class="p">]</span><span class="w">
        </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w">
          </span><span class="n">result</span><span class="w">
          </span><span class="p">(</span><span class="nf">recur</span><span class="w"> </span><span class="p">(</span><span class="nb">conj</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">dec</span><span class="w"> </span><span class="n">n</span><span class="p">))))</span><span class="w">
</span><span class="o">#</span><span class="ss">'user/count-down</span><span class="w">

</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">count-down</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w">
</span><span class="p">[</span><span class="mi">5</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w">
</span></code></pre>
<p><br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br></p>

<p>Here is another example of the use of <code>recur</code>. It will keep calling <code>count-down</code> function with updated arguments until <code>n</code> becomes 0.</p>

<p><br>
<br>
<br>
<br>
<br>
<br>
<br></p>

<p>Why do we have <code>recur</code> when you can write a recursive function with the simple recursion like we do in <code>fibo-recursive</code>? One of the most important reasons is the performance optimization.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">fibo-recursive</span><span class="w"> </span><span class="mi">100000</span><span class="p">)</span><span class="w">
</span><span class="n">StackOverflowError</span><span class="w">   </span><span class="n">clojure.lang.Numbers.equal</span><span class="w"> </span><span class="p">(</span><span class="nf">Numbers.java</span><span class="no">:216</span><span class="p">)</span><span class="w">
</span></code></pre>
<p><br></p>

<p>You cannot compute large Fibonacci number with <code>fibo-recursive</code>. When you try to do that, you will get StackOverflowError.</p>

<p>This is because, with simple recursion, each recursive call creates a stack frame which is a data to store the information of the called function on memory. Doing deep recursion requires large memory for stack frames, but since it cannot, we get StackOverflowError.</p>

<p>Although we don&#39;t go deeply into details, one of techniques to avoid this problem is making your function <strong>tail recursive</strong>. A function is tail recursive when the recursion is happening at the end of it&#39;s definition. In other words, a tail recursive function must return itself as it&#39;s returned value. When you use <code>recur</code>, it makes sure you are doing tail recursion.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">fibo-loop-recur</span><span class="w"> </span><span class="p">[</span><span class="n">current</span><span class="w"> </span><span class="nb">next</span><span class="w"> </span><span class="n">iteration</span><span class="p">]</span><span class="w">
        </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">iteration</span><span class="p">)</span><span class="w">
        </span><span class="n">current</span><span class="w">
        </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">0</span><span class="w">
          </span><span class="p">(</span><span class="nf">recur</span><span class="w"> </span><span class="nb">next</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">current</span><span class="w"> </span><span class="nb">next</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">dec</span><span class="w"> </span><span class="n">iteration</span><span class="p">)))))</span><span class="w">
</span><span class="n">CompilerException</span><span class="w"> </span><span class="n">java.lang.UnsupportedOperationException</span><span class="err">:</span><span class="w"> </span><span class="n">Can</span><span class="w"> </span><span class="n">only</span><span class="w"> </span><span class="n">recur</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="n">tail</span><span class="w"> </span><span class="n">position,</span><span class="w"> </span><span class="n">compiling</span><span class="err">:</span><span class="p">(</span><span class="nf">*cider-repl</span><span class="w"> </span><span class="n">localhost*</span><span class="no">:253:10</span><span class="p">)</span><span class="w">
</span></code></pre>
<p><br></p>

<p>In fact, you will get an error when you try to call <code>recur</code> not at the end of a function.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">fibo-recur</span><span class="w"> </span><span class="mi">100000</span><span class="p">)</span><span class="w">
</span><span class="c1">;; takes very long time to compute</span><span class="w">
</span></code></pre>
<p><br>
<br>
<br>
<br>
<br>
<br></p>

<p>Because <code>recur</code> does tail recursion, you don&#39;t get StackOverflowError with big Fibonacci number although it takes very long time to compute.</p>
<h2 id='loop'>Loop</h2>
<p>Does Clojure have for/while loop? No, Clojure doesn&#39;t provide a way to write an imperative loop because there is no mutable local variable in Clojure. However, you can use <code>loop</code> to write code that works like an imperative loop.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">count-up</span><span class="w"> </span><span class="p">[</span><span class="nb">max</span><span class="p">]</span><span class="w">
        </span><span class="p">(</span><span class="nb">loop</span><span class="w"> </span><span class="p">[</span><span class="nb">count</span><span class="w"> </span><span class="mi">0</span><span class="p">]</span><span class="w">
          </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="nb">count</span><span class="w"> </span><span class="nb">max</span><span class="p">)</span><span class="w">
            </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"Done!"</span><span class="p">)</span><span class="w">
            </span><span class="p">(</span><span class="nf">do</span><span class="w">
              </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="p">(</span><span class="nb">str</span><span class="w"> </span><span class="s">"Counting "</span><span class="w"> </span><span class="nb">count</span><span class="p">))</span><span class="w">
              </span><span class="p">(</span><span class="nf">recur</span><span class="w"> </span><span class="p">(</span><span class="nb">inc</span><span class="w"> </span><span class="nb">count</span><span class="p">))))))</span><span class="w">

</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">count-up</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w">
</span><span class="n">Counting</span><span class="w"> </span><span class="mi">0</span><span class="w">
</span><span class="n">Counting</span><span class="w"> </span><span class="mi">1</span><span class="w">
</span><span class="n">Counting</span><span class="w"> </span><span class="mi">2</span><span class="w">
</span><span class="n">Counting</span><span class="w"> </span><span class="mi">3</span><span class="w">
</span><span class="n">Counting</span><span class="w"> </span><span class="mi">4</span><span class="w">
</span><span class="n">Done!</span><span class="w">
</span><span class="n">nil</span><span class="w">
</span></code></pre>
<p><br></p>

<p>Hopefully, this code looks similar to a simple counting loop in non-functional programming languages you&#39;ve had experienced with before. In this example, <code>recur</code> increments <code>count</code> at the end of each loop and <code>loop</code> uses it in the next loop.</p>

<p><br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br></p>

<p><code>loop</code> is always used with <code>recur</code> and provides a recursion point for <code>recur</code>. A <strong>recursion point</strong> is a function entry point that <code>recur</code> can go back to do recursion. However, <code>recur</code> doesn&#39;t necessary need <code>loop</code> to do it&#39;s job as long as a recursion point is provided.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">count-up-no-loop</span><span class="w"> </span><span class="p">[</span><span class="nb">count</span><span class="w"> </span><span class="nb">max</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="nb">count</span><span class="w"> </span><span class="nb">max</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"Done!"</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nf">do</span><span class="w">
      </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="p">(</span><span class="nb">str</span><span class="w"> </span><span class="s">"Counting "</span><span class="w"> </span><span class="nb">count</span><span class="p">))</span><span class="w">
      </span><span class="p">(</span><span class="nf">recur</span><span class="w"> </span><span class="p">(</span><span class="nb">inc</span><span class="w"> </span><span class="nb">count</span><span class="p">)</span><span class="w"> </span><span class="nb">max</span><span class="p">))))</span><span class="w">

</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">count-up-no-loop</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w">
</span><span class="n">Counting</span><span class="w"> </span><span class="mi">0</span><span class="w">
</span><span class="n">Counting</span><span class="w"> </span><span class="mi">1</span><span class="w">
</span><span class="n">Counting</span><span class="w"> </span><span class="mi">2</span><span class="w">
</span><span class="n">Counting</span><span class="w"> </span><span class="mi">3</span><span class="w">
</span><span class="n">Counting</span><span class="w"> </span><span class="mi">4</span><span class="w">
</span><span class="n">Done!</span><span class="w">
</span><span class="n">nil</span><span class="w">
</span></code></pre>
<p><br></p>

<p>You can rewrite <code>count-up</code> function without <code>loop</code>. In <code>count-up-no-loop</code>, the recursion point for <code>recur</code> is the function itself. Note that <code>recur</code> takes two arguments now. This is because the number of arguments of <code>recur</code> must match that of it&#39;s recursion point function.</p>

<p><br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br></p>

<p>One final note: <code>loop/recur</code> is merely a friendly way to write recursion code. All imperative loops can be converted to recursions and all recursions can be converted to loops, so Clojure chose recursions. Although you can write code that looks like an imperative loop with <code>loop/recur</code>, Clojure is doing recursion under the hood.</p>
<h1 id='macros'>Macros</h1>
<p>Clojure&#39;s Macros gives you the power to restructure your Clojure code as you like. For example, you can create your own code syntax, invent new control flow, new types of values, etc.</p>
<h2 id='defmacro'>Defmacro</h2><pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">defmacro</span><span class="w"> </span><span class="n">unless</span><span class="w"> </span><span class="p">[</span><span class="nb">test</span><span class="w"> </span><span class="n">then</span><span class="p">]</span><span class="w">
           </span><span class="s">"Evaluates then when test evaluates to be falsey"</span><span class="w">
           </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="ss">'if</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="ss">'not</span><span class="w"> </span><span class="nb">test</span><span class="p">)</span><span class="w">
            </span><span class="n">then</span><span class="p">))</span><span class="w">

</span><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">unless</span><span class="w"> </span><span class="n">false</span><span class="w"> </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"false!!"</span><span class="p">))</span><span class="w">
</span><span class="n">false!!</span><span class="w">
</span><span class="n">nil</span><span class="w">

</span><span class="c1">;; Error</span><span class="w">
</span><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">defmacro</span><span class="w"> </span><span class="n">unless</span><span class="w"> </span><span class="p">[</span><span class="nb">test</span><span class="w"> </span><span class="n">then</span><span class="p">]</span><span class="w">
           </span><span class="s">"Evaluates then when test evaluates to be falsey"</span><span class="w">
           </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="nb">not</span><span class="w"> </span><span class="nb">test</span><span class="p">)</span><span class="w">
            </span><span class="n">then</span><span class="p">))</span><span class="w">

</span><span class="n">CompilerException</span><span class="w"> </span><span class="n">java.lang.RuntimeException</span><span class="err">:</span><span class="w"> </span><span class="n">Unable</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="nb">resolve</span><span class="w"> </span><span class="nb">symbol</span><span class="err">:</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="n">context,</span><span class="w"> </span><span class="n">compiling</span><span class="err">:</span><span class="p">(</span><span class="nf">NO_SOURCE_PATH</span><span class="no">:3:12</span><span class="p">)</span><span class="w">
</span></code></pre>
<p><br></p>

<p>To define a macro, use <code>defmacro</code>. Like function, you can give it a name, docs, and arguments. Note that you are using quotes <code>&#39;</code> followed by <code>if</code> and <code>not</code>.
This is because you don&#39;t want them to be evaluated when you define the macro.</p>

<p><br>
<br>
<br>
<br></p>

<p>Without quotes, you will see an exception.</p>
<h2 id='macroexpand'>Macroexpand</h2><pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">macroexpand</span><span class="w"> </span><span class="o">'</span><span class="p">(</span><span class="nf">unless</span><span class="w"> </span><span class="n">false</span><span class="w"> </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"hi"</span><span class="p">)))</span><span class="w">
</span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">not</span><span class="w"> </span><span class="n">false</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"hi"</span><span class="p">))</span><span class="w">
</span></code></pre>
<p><br></p>

<p>Macros are replaced with Clojure code before it&#39;s evaluated. To see how it will be replaced without actually evaluating the macro, use <code>macroexpand</code>.
Note that you have to use <code>&#39;</code> because you want it to be unevaluated list.</p>
<h2 id='quotes'>Quotes</h2><pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w">
</span><span class="mi">3</span><span class="w">


</span><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">quote</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="p">))</span><span class="w">
</span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w">


</span><span class="n">user=&gt;</span><span class="w"> </span><span class="o">'</span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w">
</span></code></pre>
<p><br></p>

<p>Without a quote, this expression will be just evaluated and returns the value.</p>

<p><br></p>

<p>However, when an expression is surrounded by <code>quote</code>, it does not evaluate the expression but returns the expression itself.</p>

<p><br></p>

<p><code>&#39;</code> is another form of <code>quote</code>. It does the exactly same thing with <code>quote</code>. <code>&#39;</code> is used more often than <code>quote</code> since it&#39;s concise.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">defmacro</span><span class="w"> </span><span class="n">unless</span><span class="w"> </span><span class="p">[</span><span class="nb">test</span><span class="w"> </span><span class="n">then</span><span class="p">]</span><span class="w">
           </span><span class="s">"Evaluates then when test evaluates to be falsey"</span><span class="w">
           </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="ss">'if</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="ss">'not</span><span class="w"> </span><span class="nb">test</span><span class="p">)</span><span class="w">
            </span><span class="n">then</span><span class="p">))</span><span class="w">
</span></code></pre>
<p><br></p>

<p>You can see quoting at work in macros. In this <code>unless</code> macro, you need to use <code>&#39;</code> followed by <code>if</code> and <code>not</code> because you don&#39;t want them to be evaluated inside the macro definition.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="ss">'clojure.string</span><span class="p">)</span><span class="w">
</span><span class="n">nil</span><span class="w">
</span></code></pre>
<p><br>
<br>
<br></p>

<p>Another common place where quote is used is when loading a namespace.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="n">clojure.string</span><span class="p">)</span><span class="w">
</span><span class="n">CompilerException</span><span class="w"> </span><span class="n">java.lang.ClassNotFoundException</span><span class="err">:</span><span class="w"> </span><span class="n">clojure.string,</span><span class="w"> </span><span class="n">compiling</span><span class="err">:</span><span class="p">(</span><span class="nf">*cider-repl</span><span class="w"> </span><span class="n">localhost*</span><span class="no">:483:7</span><span class="p">)</span><span class="w">
</span></code></pre>
<p>You need to quote <code>clojure.string</code> namespace otherwise Clojure tries to resolve the namespace symbol and get error. This is because resolving symbol is the default treatment but <code>clojure.string</code> symbol is not bound to a value.</p>
<h2 id='syntax-quotes'>Syntax-Quotes</h2><pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="o">`</span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="nf">clojure.core/+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w">
</span></code></pre>
<p><br></p>

<p>Syntax quoting <code>`</code>works very similarly to quoting <code>&#39;</code>: it returns an unevaluated expression.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="o">'</span><span class="p">(</span><span class="nb">dec</span><span class="w"> </span><span class="p">(</span><span class="nb">inc</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span><span class="w">
</span><span class="p">(</span><span class="nb">dec</span><span class="w"> </span><span class="p">(</span><span class="nb">inc</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span><span class="w">

</span><span class="n">user=&gt;</span><span class="w"> </span><span class="o">`</span><span class="p">(</span><span class="nb">dec</span><span class="w"> </span><span class="p">(</span><span class="nb">inc</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span><span class="w">
</span><span class="p">(</span><span class="nf">clojure.core/dec</span><span class="w"> </span><span class="p">(</span><span class="nf">clojure.core/inc</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span><span class="w">
</span></code></pre>
<p><br>
<br></p>

<p>However, you see the difference from quoting when the expression contains symbols. Unlike quoting, syntax-quoting returns the fully qualified namespace.
Using fully qualified namespace is very important in order to avoid name conflicts when defining macro.</p>
<h2 id='unquotes'>Unquotes</h2><pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="o">'</span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">~</span><span class="p">(</span><span class="nb">inc</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span><span class="w">
</span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">(</span><span class="nf">clojure.core/unquote</span><span class="w"> </span><span class="p">(</span><span class="nb">inc</span><span class="w"> </span><span class="mi">1</span><span class="p">)))</span><span class="w">

</span><span class="n">user=&gt;</span><span class="w"> </span><span class="o">`</span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">~</span><span class="p">(</span><span class="nb">inc</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span><span class="w">
</span><span class="p">(</span><span class="nf">clojure.core/+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w">
</span></code></pre>
<p><br></p>

<p>You will see another difference between syntax quoting and quoting when syntax quoting is used with unquoting <code>~</code>. Syntax quoting allows unquoting to evaluate the expression followed by <code>~</code>.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="o">'</span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">~</span><span class="p">(</span><span class="nb">inc</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span><span class="w">
</span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">(</span><span class="nf">clojure.core/unquote</span><span class="w"> </span><span class="p">(</span><span class="nb">inc</span><span class="w"> </span><span class="mi">1</span><span class="p">)))</span><span class="w">
</span></code></pre>
<p><br>
<br>
<br>
<br></p>

<p>Quoting doesn&#39;t allow unquoting to evaluate an expression.</p>
<h2 id='unquote-splice'>Unquote-Splice</h2><pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="o">`</span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="o">~</span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">))</span><span class="w">
</span><span class="p">(</span><span class="nf">clojure.core/+</span><span class="w"> </span><span class="p">(</span><span class="nf">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">))</span><span class="w">

</span><span class="n">user=&gt;</span><span class="w"> </span><span class="o">`</span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="o">~@</span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">))</span><span class="w">
</span><span class="p">(</span><span class="nf">clojure.core/+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w">
</span></code></pre>
<p><br></p>

<p>The <code>~@</code> unquote splice works just like <code>~</code> unquote, except it expands a sequence and splice the contents of the sequence into the enclosing syntax-quoted data structure.</p>
<h1 id='threading-macros'>Threading Macros</h1>
<p>Threading Macros are macros that helps you to write nested forms in a cleaner and more readable way. Despite it&#39;s name, threading macros are nothing to do with threads in the parallel computing.</p>
<h2 id='gt'>-&gt;</h2>
<p><code>-&gt;</code> is called thread-first macro. It&#39;s <em>first</em> because it&#39;s passing down the evaluation of former forms to the first argument of preceding forms.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">conj</span><span class="w"> </span><span class="p">(</span><span class="nb">conj</span><span class="w"> </span><span class="p">(</span><span class="nb">conj</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w">
</span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="w">
</span></code></pre>
<p>Suppose if you want to start from an empty vector and adding numbers to the vector one by one. Here is nested version of the code.</p>

<p><br></p>

<p>As you add more numbers, the nesting gets deeper and makes your code harder to read. The thread-first macro solves this nesting problem.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="p">[]</span><span class="w">
          </span><span class="p">(</span><span class="nb">conj</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w">
          </span><span class="p">(</span><span class="nb">conj</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w">
          </span><span class="p">(</span><span class="nb">conj</span><span class="w"> </span><span class="mi">3</span><span class="p">))</span><span class="w">
</span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="w">
</span></code></pre>
<p>Here is the same code with thread-first macro.</p>

<p>The first argument is the initial value that you want to start from. After the first argument is evaluated, it is then passed to the first argument of <code>(conj 1)</code>. This is equivalent to <code>(conj [] 1)</code>. The evaluated value is then passed to to the first argument of <code>(conj 2)</code>. This is equivalent to <code>(conj [1] 2)</code>. Finally, we are evaluating <code>(conj [1 2] 3)</code> which returns <code>[1 2 3]</code>.</p>
<h2 id='gt-gt'>-&gt;&gt;</h2>
<p><code>-&gt;&gt;</code> is called thread-last macro. It&#39;s <em>last</em> because it&#39;s passing down the evaluation of former forms to the last argument of preceding forms.</p>

<p><code>map</code> is an example of such function that takes a collection in the last argument and apply the function in the first argument.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">-&gt;&gt;</span><span class="w"> </span><span class="p">[</span><span class="s">"Japan"</span><span class="w"> </span><span class="s">"China"</span><span class="w"> </span><span class="s">"Korea"</span><span class="p">]</span><span class="w">
           </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="n">clojure.string/upper-case</span><span class="p">)</span><span class="w">
           </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="o">#</span><span class="p">(</span><span class="nb">str</span><span class="w"> </span><span class="s">"Hello "</span><span class="w"> </span><span class="n">%</span><span class="p">)))</span><span class="w">
</span><span class="p">(</span><span class="s">"Hello JAPAN!"</span><span class="w"> </span><span class="s">"Hello CHINA!"</span><span class="w"> </span><span class="s">"Hello KOREA!"</span><span class="p">)</span><span class="w">
</span></code></pre>
<p>This code converts country names to upper case and say hello to the countries. The vector of country names are passed to the last argument of the first map which is equivalent to <code>(map clojure.string/upper-case [&quot;japan&quot; &quot;china&quot; &quot;korea&quot;])</code>. Then it&#39;s passed to the second map which is equivalent to <code>(map #(str &quot;Hello &quot; %) [&quot;JAPAN&quot; &quot;CHINA&quot; &quot;KOREA&quot;])</code>.</p>

<p>Remember that <code>#()</code> is another way to write a anonymous function.</p>
<h1 id='delays'>Delays</h1><h2 id='delay'>Delay</h2>
<p>When you want to defer the evaluation of an expression, use <code>delay</code>.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">later</span><span class="w"> </span><span class="p">(</span><span class="nf">do</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="p">(</span><span class="nb">prn</span><span class="w"> </span><span class="s">"Adding"</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="p">)))</span><span class="w">
</span><span class="s">"Adding"</span><span class="w">
</span><span class="o">#</span><span class="ss">'user/later</span><span class="w">


</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">later</span><span class="w"> </span><span class="p">(</span><span class="nf">delay</span><span class="w"> </span><span class="p">(</span><span class="nf">do</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="p">(</span><span class="nb">prn</span><span class="w"> </span><span class="s">"Adding"</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="p">))))</span><span class="w">
</span><span class="o">#</span><span class="ss">'user/later</span><span class="w">
</span></code></pre>
<p><br></p>

<p>This is the example of immediately evaluating an expression. Nothing special is involved  here. <code>(do ...)</code> is executed immediately and it&#39;s return value is bound to <code>later</code> var.</p>

<p><br></p>

<p>When you use <code>delay</code>, the expression is not evaluated immediately, so &quot;Adding&quot; is not printed.</p>
<h2 id='force'>Force</h2><pre class="highlight clojure tab-clojure"><code><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">later</span><span class="w"> </span><span class="p">(</span><span class="nf">delay</span><span class="w"> </span><span class="p">(</span><span class="nf">do</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="p">(</span><span class="nb">prn</span><span class="w"> </span><span class="s">"Adding"</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="p">))))</span><span class="w">
</span><span class="o">#</span><span class="ss">'user/later</span><span class="w">

</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">force</span><span class="w"> </span><span class="n">later</span><span class="p">)</span><span class="w">
</span><span class="s">"Adding"</span><span class="w">
</span><span class="mi">3</span><span class="w">
</span></code></pre>
<p><br>
<br>
<br>
<br></p>

<p>To evaluate and obtain the result of a delayed expression, use <code>force</code>.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">later</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="p">(</span><span class="nb">prn</span><span class="w"> </span><span class="s">"Adding"</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">))</span><span class="w">

</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">later</span><span class="p">)</span><span class="w">
</span><span class="s">"Adding"</span><span class="w">
</span><span class="mi">3</span><span class="w">
</span></code></pre>
<p><br>
<br>
<br></p>

<p>You can achieve the same thing by using an anonymous function and <code>def</code>. Then, why do we get bothered with delay?</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">later</span><span class="w"> </span><span class="p">(</span><span class="nf">delay</span><span class="w"> </span><span class="p">(</span><span class="nf">do</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="p">(</span><span class="nb">prn</span><span class="w"> </span><span class="s">"Adding"</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="p">))))</span><span class="w">
</span><span class="o">#</span><span class="ss">'user/later</span><span class="w">

</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">force</span><span class="w"> </span><span class="n">later</span><span class="p">)</span><span class="w">
</span><span class="s">"Adding"</span><span class="w">
</span><span class="mi">3</span><span class="w">

</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">force</span><span class="w"> </span><span class="n">later</span><span class="p">)</span><span class="w">
</span><span class="mi">3</span><span class="w">
</span></code></pre>
<p><br>
<br>
<br>
<br></p>

<p>The difference from a plain function is that delay is only evaluated once and caches the result. &quot;Adding&quot; is only printed once because delay returns cached result from the second time.</p>
<h1 id='futures'>Futures</h1><h2 id='future'>Future</h2><pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">do</span><span class="w">
         </span><span class="p">(</span><span class="nf">Thread/sleep</span><span class="w"> </span><span class="mi">3000</span><span class="p">)</span><span class="w">
         </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"hello"</span><span class="p">))</span><span class="w">

</span><span class="c1">;; Wait for 3 sec and then "hello" is printed</span><span class="w">
</span><span class="n">hello</span><span class="w">
</span><span class="n">nil</span><span class="w">
</span></code></pre>
<p><br>
&quot;hello&quot; is printed after sleeping 3 seconds. This is very obvious because these lines of the code are executed synchronously.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">do</span><span class="w">
          </span><span class="p">(</span><span class="nf">future</span><span class="w">
          </span><span class="p">(</span><span class="nf">Thread/sleep</span><span class="w"> </span><span class="mi">3000</span><span class="p">)</span><span class="w">
          </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"after sleep"</span><span class="p">))</span><span class="w">
          </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"hello"</span><span class="p">))</span><span class="w">
</span><span class="n">hello</span><span class="w">
</span><span class="n">nil</span><span class="w">
</span><span class="n">after</span><span class="w"> </span><span class="n">sleep</span><span class="w">
</span></code></pre>
<p><br>
<br>
<br>
<br>
<br>
<br></p>

<p>If you use <code>future</code>, <code>(println &quot;hello&quot;)</code> is evaluated immediately, and after three seconds, <code>(println &quot;after sleep&quot;)</code> will be evaluated.
This is because Clojure puts the expression grouped by <code>future</code> into another thread and moves the current thread forward.</p>

<p><br>
<br></p>

<p>Calls inside future still blocks. So, in this case, &quot;after sleep&quot; is printed after 3 secs.</p>
<h2 id='deref'>Deref</h2><pre class="highlight clojure tab-clojure"><code><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">future-val</span><span class="w"> </span><span class="p">(</span><span class="nf">future</span><span class="w"> </span><span class="p">(</span><span class="nb">inc</span><span class="w"> </span><span class="mi">1</span><span class="p">))]</span><span class="w">
         </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="n">future-val</span><span class="p">))</span><span class="w">
</span><span class="o">#</span><span class="n">&lt;core$future_call$reify__6320</span><span class="err">@</span><span class="mi">142</span><span class="n">cbba</span><span class="err">:</span><span class="w"> </span><span class="mi">2</span><span class="nb">&gt;</span><span class="w">
</span><span class="n">nil</span><span class="w">


</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">future-val</span><span class="w"> </span><span class="p">(</span><span class="nf">future</span><span class="w"> </span><span class="p">(</span><span class="nb">inc</span><span class="w"> </span><span class="mi">1</span><span class="p">))]</span><span class="w">
         </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="p">(</span><span class="nb">deref</span><span class="w"> </span><span class="n">future-val</span><span class="p">)))</span><span class="w">
</span><span class="mi">2</span><span class="w">
</span><span class="n">nil</span><span class="w">
</span></code></pre>
<p><br></p>

<p><code>future</code> can return values.</p>

<p>See the returned value <code>#&lt;core$future_call$reify__6320@142cbba: 2&gt;</code> which is not what you want. This returned value is the current state of the future, not the returned value of <code>(inc 1)</code></p>

<p><br></p>

<p>To obtain the returned value of <code>(inc 1)</code>, you need to dereference the future with <code>deref</code>.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user&gt;</span><span class="w">  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">future-val</span><span class="w"> </span><span class="p">(</span><span class="nf">future</span><span class="w"> </span><span class="p">(</span><span class="nb">inc</span><span class="w"> </span><span class="mi">1</span><span class="p">))]</span><span class="w">
         </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="err">@</span><span class="n">future-val</span><span class="p">))</span><span class="w">
</span><span class="mi">2</span><span class="w">
</span><span class="n">nil</span><span class="w">
</span></code></pre>
<p><br>
<br>
<br>
<br></p>

<p>You can also use <code>@</code> to dereference a future.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user&gt;</span><span class="w"> </span><span class="err">@</span><span class="p">(</span><span class="nf">future</span><span class="w"> </span><span class="p">(</span><span class="nf">Thread/sleep</span><span class="w"> </span><span class="mi">3000</span><span class="p">)</span><span class="w"> </span><span class="s">"returned!"</span><span class="p">)</span><span class="w">
</span><span class="c1">;; Waiting three seconds...</span><span class="w">
</span><span class="s">"returned!"</span><span class="w">
</span></code></pre>
<p><br>
<br>
<br>
<br></p>

<p>When you dereference a future, you will block until the result is returned.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user&gt;</span><span class="w">  </span><span class="p">(</span><span class="nb">deref</span><span class="w"> </span><span class="p">(</span><span class="nf">future</span><span class="w"> </span><span class="p">(</span><span class="nf">Thread/sleep</span><span class="w"> </span><span class="mi">1000</span><span class="p">)</span><span class="w"> </span><span class="s">"I made it!"</span><span class="p">)</span><span class="w"> </span><span class="mi">2000</span><span class="w"> </span><span class="s">"Can't wait anymore!"</span><span class="p">)</span><span class="w">
</span><span class="s">"I made it!"</span><span class="w">

</span><span class="n">user&gt;</span><span class="w">  </span><span class="p">(</span><span class="nb">deref</span><span class="w"> </span><span class="p">(</span><span class="nf">future</span><span class="w"> </span><span class="p">(</span><span class="nf">Thread/sleep</span><span class="w"> </span><span class="mi">3000</span><span class="p">)</span><span class="w"> </span><span class="s">"I made it!"</span><span class="p">)</span><span class="w"> </span><span class="mi">2000</span><span class="w"> </span><span class="s">"Can't wait anymore!"</span><span class="p">)</span><span class="w">
</span><span class="s">"Can't wait anymore!"</span><span class="w">
</span></code></pre>
<p><br>
<br>
<br></p>

<p>You can tell <code>deref</code> how long you want to wait along with a value to return if it does time out.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">sleep-and-wait</span><span class="w">
         </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="nb">time</span><span class="p">]</span><span class="w">
           </span><span class="p">(</span><span class="nf">future</span><span class="w">
             </span><span class="p">(</span><span class="nf">Thread/sleep</span><span class="w"> </span><span class="nb">time</span><span class="p">)</span><span class="w">
             </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="p">(</span><span class="nb">str</span><span class="w"> </span><span class="s">"slept "</span><span class="w"> </span><span class="nb">time</span><span class="w"> </span><span class="s">" sec"</span><span class="w"> </span><span class="p">))))</span><span class="w">
               </span><span class="p">[</span><span class="mi">1000</span><span class="w"> </span><span class="mi">2000</span><span class="p">])]</span><span class="w">
     </span><span class="p">(</span><span class="nb">doall</span><span class="w"> </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="nb">deref</span><span class="w"> </span><span class="n">sleep-and-wait</span><span class="p">))</span><span class="w">
     </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"done"</span><span class="p">))</span><span class="w">
</span><span class="n">slept</span><span class="w"> </span><span class="mi">1000</span><span class="w"> </span><span class="n">sec</span><span class="w">
</span><span class="n">slept</span><span class="w"> </span><span class="mi">2000</span><span class="w"> </span><span class="n">sec</span><span class="w">
</span><span class="n">done</span><span class="w">
</span></code></pre>
<p><br>
<br>
<br>
<br>
<br>
<br></p>

<p>Finally, you can do a useful thing by combining <code>future</code> and <code>deref</code>. You can run multiple time consuming tasks in different threads and block until they finish.</p>
<h2 id='realized'>Realized?</h2><pre class="highlight clojure tab-clojure"><code><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">my-future</span><span class="w"> </span><span class="p">(</span><span class="nf">future</span><span class="w"> </span><span class="p">(</span><span class="nf">Thread/sleep</span><span class="w"> </span><span class="mi">5000</span><span class="p">)</span><span class="w"> </span><span class="p">))</span><span class="w">

</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">repeatedly</span><span class="w"> </span><span class="mi">6</span><span class="w">
        </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[]</span><span class="w">
        </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="p">(</span><span class="nf">realized?</span><span class="w"> </span><span class="n">my-future</span><span class="p">))</span><span class="w">
        </span><span class="p">(</span><span class="nf">Thread/sleep</span><span class="w"> </span><span class="mi">1000</span><span class="p">)))</span><span class="w">

</span><span class="o">#</span><span class="ss">'user/my-futurefalse</span><span class="w">
</span><span class="n">false</span><span class="w">
</span><span class="n">false</span><span class="w">
</span><span class="n">false</span><span class="w">
</span><span class="n">false</span><span class="w">
</span><span class="n">true</span><span class="w">
</span></code></pre>
<p><br>
<br>
<br></p>

<p>To know if a future is already done, use <code>realized?</code>.</p>

<p><br>
<br>
<br></p>

<p><code>realized</code> returns true after 5 seconds.</p>
<h1 id='promises'>Promises</h1><h2 id='promise'>Promise</h2>
<p>When you want to defer the evaluation of expressions until you obtain values to pass to them, use <code>promise</code>. The easiest example why you want to use promise is implementing a callback.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">my-promise</span><span class="w"> </span><span class="p">(</span><span class="nf">promise</span><span class="p">))</span><span class="w">
</span><span class="o">#</span><span class="ss">'user/my-promise</span><span class="w">

</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">listen-and-callback</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[]</span><span class="w">
  </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"Start listening..."</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nf">future</span><span class="w"> </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"Callback fired: "</span><span class="w"> </span><span class="err">@</span><span class="n">my-promise</span><span class="p">))))</span><span class="w">
</span><span class="o">#</span><span class="ss">'user/listen-and-callback</span><span class="w">

</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">do-time-consuming-job</span><span class="w"> </span><span class="p">[]</span><span class="w">
  </span><span class="p">(</span><span class="nf">Thread/sleep</span><span class="w"> </span><span class="mi">5000</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nf">deliver</span><span class="w"> </span><span class="n">my-promise</span><span class="w"> </span><span class="s">"delivered value"</span><span class="p">))</span><span class="w">
</span><span class="o">#</span><span class="ss">'user/do-time-consuming-job</span><span class="w">

</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">listen-and-callback</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">do-time-consuming-job</span><span class="p">)</span><span class="w">
</span><span class="n">Start</span><span class="w"> </span><span class="n">listening...</span><span class="w">
</span><span class="n">Callback</span><span class="w"> </span><span class="n">fired</span><span class="err">:</span><span class="w">  </span><span class="n">delivered</span><span class="w"> </span><span class="n">value</span><span class="w">
</span></code></pre>
<p><br></p>

<p>First, you make a promise with <code>promise</code>.</p>

<p><br>
Creating a listener that listens to the promise and fire the callback when a value is delivered to the promise. Just like future, promise will block when you dereference it.</p>

<p><br>
<br>
Defining a job that takes 5 seconds to finish.</p>

<p><br>
<br>
<br>
Now let&#39;s start the listener and wait for the time consuming job. After being blocked by the dereference of <code>@my-promise</code> for 5 seconds, you will see the callback is fired.</p>
<h1 id='atoms'>Atoms</h1><h2 id='atom'>Atom</h2>
<p>You&#39;ve might hear this statement before: <em>there is no state in Clojure. Thus, the language is impractical and cannot be used to build real applications.</em> However, this is not true. Clojure has built-in mechanisms to manage application state. <code>Atom</code> is one of the mechanisms.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">atom-str</span><span class="w"> </span><span class="p">(</span><span class="nf">atom</span><span class="w"> </span><span class="s">"hello"</span><span class="p">))</span><span class="w">
</span><span class="o">#</span><span class="ss">'user/atom-str</span><span class="w">
</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">atom-vector</span><span class="w"> </span><span class="p">(</span><span class="nf">atom</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">]))</span><span class="w">
</span><span class="o">#</span><span class="ss">'user/atom-vector</span><span class="w">
</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">atom-map</span><span class="w"> </span><span class="p">(</span><span class="nf">atom</span><span class="w"> </span><span class="p">{</span><span class="no">:a</span><span class="w"> </span><span class="s">"aaa"</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="s">"bbb"</span><span class="p">}))</span><span class="w">
</span><span class="o">#</span><span class="ss">'user/atom-map</span><span class="w">
</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">atom-int</span><span class="w"> </span><span class="p">(</span><span class="nf">atom</span><span class="w"> </span><span class="mi">53</span><span class="p">))</span><span class="w">
</span><span class="o">#</span><span class="ss">'user/atom-int</span><span class="w">
</span></code></pre>
<p><br></p>

<p>Use <code>atom</code> to create an atom that points to a value. You can create an atom of any values.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">deref</span><span class="w"> </span><span class="n">atom-int</span><span class="p">)</span><span class="w">
</span><span class="mi">53</span><span class="w">

</span><span class="n">user&gt;</span><span class="w"> </span><span class="err">@</span><span class="n">atom-int</span><span class="w">
</span><span class="mi">53</span><span class="w">
</span></code></pre>
<p><br>
<br>
<br>
<br>
<br>
<br>
<br>
<br></p>

<p>To obtain the value of an atom, use <code>deref</code> or <code>@</code>.</p>
<h2 id='reset'>Reset!</h2><pre class="highlight clojure tab-clojure"><code><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">atom-int</span><span class="w"> </span><span class="p">(</span><span class="nf">atom</span><span class="w"> </span><span class="mi">53</span><span class="p">))</span><span class="w">
</span><span class="o">#</span><span class="ss">'user/atom-int</span><span class="w">

</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">reset!</span><span class="w"> </span><span class="n">atom-int</span><span class="w"> </span><span class="mi">35</span><span class="p">)</span><span class="w">
</span><span class="mi">35</span><span class="w">

</span><span class="n">user&gt;</span><span class="w"> </span><span class="err">@</span><span class="n">atom-int</span><span class="w">
</span><span class="mi">35</span><span class="w">
</span></code></pre>
<p><br></p>

<p>You can set the value of an atom with <code>reset!</code>. It is used when you are setting the value without regard for the
current value, normally the first time you create the atom.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">reset!</span><span class="w"> </span><span class="n">atom-int</span><span class="w"> </span><span class="mi">100</span><span class="p">)</span><span class="w">
</span><span class="mi">100</span><span class="w">

</span><span class="n">user&gt;</span><span class="w"> </span><span class="err">@</span><span class="n">atom-int</span><span class="w">
</span><span class="mi">100</span><span class="w">

</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">reset!</span><span class="w"> </span><span class="n">atom-int</span><span class="w"> </span><span class="mi">200</span><span class="p">)</span><span class="w">
</span><span class="mi">200</span><span class="w">

</span><span class="n">user&gt;</span><span class="w"> </span><span class="err">@</span><span class="n">atom-int</span><span class="w">
</span><span class="mi">200</span><span class="w">
</span></code></pre>
<p><br>
<br>
<br>
<br>
<br>
<br>
<br>
<br></p>

<p>Atoms are mutable, so you can update as many times as you want.</p>
<h2 id='swap'>Swap!</h2>
<p><code>swap!</code> allows you to use a function to update the value of an atom.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">atom-int</span><span class="w"> </span><span class="p">(</span><span class="nf">atom</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span><span class="w">
</span><span class="o">#</span><span class="ss">'user/atom-int</span><span class="w">

</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">swap!</span><span class="w"> </span><span class="n">atom-int</span><span class="w">
        </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">current-atom</span><span class="p">]</span><span class="w">
            </span><span class="p">(</span><span class="nb">inc</span><span class="w"> </span><span class="n">current-atom</span><span class="p">)))</span><span class="w">
</span><span class="mi">1</span><span class="w">

</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">swap!</span><span class="w"> </span><span class="n">atom-int</span><span class="w">
        </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">_</span><span class="p">]</span><span class="w">
            </span><span class="s">"not int"</span><span class="p">))</span><span class="w">
</span><span class="s">"not int"</span><span class="w">

</span><span class="n">user&gt;</span><span class="w"> </span><span class="err">@</span><span class="n">atom-int</span><span class="w">
</span><span class="s">"not int"</span><span class="w">
</span></code></pre>
<p><br>
<br>
<br></p>

<p>The function that you pass to <code>swap!</code> will take an argument which is the current atom.</p>

<p><br>
<br>
<br></p>

<p>The atom is updated by the return value of the function.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">atom-int</span><span class="w"> </span><span class="p">(</span><span class="nf">atom</span><span class="w"> </span><span class="mi">100</span><span class="p">))</span><span class="w">
</span><span class="o">#</span><span class="ss">'user/atom-int</span><span class="w">

</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">multiple-by</span><span class="w">
        </span><span class="p">[</span><span class="n">current-atom</span><span class="w"> </span><span class="n">num</span><span class="p">]</span><span class="w">
        </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">current-atom</span><span class="w"> </span><span class="n">num</span><span class="p">))</span><span class="w">

</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">swap!</span><span class="w"> </span><span class="n">atom-int</span><span class="w"> </span><span class="n">multiple-by</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w">
</span><span class="mi">1000</span><span class="w">
</span></code></pre>
<p><br>
<br>
<br>
<br>
<br>
<br>
<br></p>

<p>You can pass a function that takes multiple arguments. The first argument of the function is the current atom.</p>
<h2 id='thread-safety'>Thread Safety</h2>
<p>Atoms are very similar to mutable variables in other programming languages. You can assign value to an atom and update anytime you want. However, Clojure&#39;s atom has one big advantage over them: it&#39;s <code>thread safe</code>.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w">
</span><span class="o">#</span><span class="ss">'user/x</span><span class="w">

</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">repeatedly</span><span class="w"> </span><span class="mi">10</span><span class="w">
        </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">(</span><span class="nb">inc</span><span class="w"> </span><span class="n">x</span><span class="p">))))</span><span class="w">
</span><span class="p">(</span><span class="o">#</span><span class="ss">'user/x...</span><span class="w">

</span><span class="n">user&gt;</span><span class="w"> </span><span class="n">x</span><span class="w">
</span><span class="mi">10</span><span class="w">
</span></code></pre>
<p><br></p>

<p>This will update <code>x</code> ten times and increment <code>x</code> by 1 every time. The final value of <code>x</code> will be 10.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w">
</span><span class="o">#</span><span class="ss">'user/x</span><span class="w">

</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">repeatedly</span><span class="w"> </span><span class="mi">10</span><span class="w">
        </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="p">(</span><span class="nf">future</span><span class="w"> </span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">(</span><span class="nb">inc</span><span class="w"> </span><span class="n">x</span><span class="p">)))))</span><span class="w">
</span><span class="p">(</span><span class="o">#</span><span class="n">&lt;core$future_call$reify__6320</span><span class="err">@</span><span class="mi">410</span><span class="n">e4786</span><span class="err">:</span><span class="w"> </span><span class="no">:pending&gt;</span><span class="w"> </span><span class="o">#</span><span class="n">&lt;core$futur...</span><span class="w">

</span><span class="n">user&gt;</span><span class="w"> </span><span class="n">x</span><span class="w">
</span><span class="mi">5</span><span class="w">
</span></code></pre>
<p><br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br></p>

<p>Similarly, this will update <code>x</code> ten times and increment <code>x</code> every time like the previous example. However, with this code, <code>(def x (inc x))</code> will be executed in parallel on different threads because we are using <code>future</code>. When you do this, the final value of <code>x</code> will not be deterministic anymore. Sometimes it is 5, and sometimes 9 because each thread access and update the same <code>x</code> in its own timing.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">(</span><span class="nf">atom</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span><span class="w">
</span><span class="o">#</span><span class="ss">'user/x</span><span class="w">

</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">repeatedly</span><span class="w"> </span><span class="mi">10</span><span class="w">
        </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="p">(</span><span class="nf">future</span><span class="w"> </span><span class="p">(</span><span class="nf">swap!</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="nb">inc</span><span class="p">))))</span><span class="w">
</span><span class="p">(</span><span class="o">#</span><span class="n">&lt;core$future_call$reify__6320</span><span class="err">@</span><span class="mi">632796</span><span class="n">c6</span><span class="err">:</span><span class="w"> </span><span class="no">:pending&gt;...</span><span class="w">

</span><span class="n">user&gt;</span><span class="w"> </span><span class="err">@</span><span class="n">x</span><span class="w">
</span><span class="mi">10</span><span class="w">
</span></code></pre>
<p><br>
<br>
<br>
<br>
<br></p>

<p>Now atom comes to rescue. <code>x</code> is atom and we use <code>swap!</code> to update the value. Unlike vars, atom is thread safe, so <code>x</code> will be updated by one thread at one time. Thus, the final value of <code>x</code> is guaranteed to be 10. This is achieved thanks to the Clojure&#39;s use of <a href="http://en.wikipedia.org/wiki/Compare-and-swap">compare-and-swap</a> in atom.</p>
<h1 id='refs'>Refs</h1><h2 id='ref'>Ref</h2>
<p>While <code>Atom</code> is handy to manage a state in a consistent way, <code>Ref</code> allows you to manage multiple states while ensuring they are consistent.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">my-ref</span><span class="w"> </span><span class="p">(</span><span class="nb">ref</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span><span class="w">
</span><span class="o">#</span><span class="ss">'user/my-ref</span><span class="w">
</span></code></pre>
<p><br></p>

<p>To create a ref, use <code>ref</code>.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">deref</span><span class="w"> </span><span class="n">my-ref</span><span class="p">)</span><span class="w">
</span><span class="mi">0</span><span class="w">

</span><span class="n">user&gt;</span><span class="w"> </span><span class="err">@</span><span class="n">my-ref</span><span class="w">
</span><span class="mi">0</span><span class="w">
</span></code></pre>
<p><br>
<br></p>

<p>To obtain the value of a ref, use <code>deref</code> or <code>@</code>.</p>
<h2 id='do-sync'>Do-sync</h2><pre class="highlight clojure tab-clojure"><code><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">deref</span><span class="w"> </span><span class="n">my-ref</span><span class="p">)</span><span class="w">
</span><span class="mi">0</span><span class="w">

</span><span class="n">user&gt;</span><span class="w"> </span><span class="err">@</span><span class="n">my-ref</span><span class="w">
</span><span class="mi">0</span><span class="w">

</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">dosync</span><span class="w">
       </span><span class="p">(</span><span class="nb">ref-set</span><span class="w"> </span><span class="n">my-ref</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w">
       </span><span class="p">(</span><span class="nb">ref-set</span><span class="w"> </span><span class="n">my-ref</span><span class="w"> </span><span class="mi">2</span><span class="p">))</span><span class="w">
</span><span class="mi">2</span><span class="w">

</span><span class="n">user&gt;</span><span class="w"> </span><span class="err">@</span><span class="n">my-ref</span><span class="w">
</span><span class="mi">2</span><span class="w">
</span></code></pre>
<p><br>
<br>
<br>
<br>
<br>
<br></p>

<p>The update of refs must be done inside <code>dosync</code> block. <code>dosync</code> is telling Clojure where the transaction update starts from. To set a ref to a new value, use <code>ref-set</code>.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">ref-set</span><span class="w"> </span><span class="n">my-ref</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w">
</span><span class="n">IllegalStateException</span><span class="w"> </span><span class="n">No</span><span class="w"> </span><span class="n">transaction</span><span class="w"> </span><span class="n">running</span><span class="w">  </span><span class="n">clojure.lang.LockingTransaction.getEx</span><span class="w"> </span><span class="p">(</span><span class="nf">LockingTransaction.java</span><span class="no">:208</span><span class="p">)</span><span class="w">
</span></code></pre>
<p><br>
<br>
<br>
<br>
<br>
<br></p>

<p>Any updates to refs <strong>always</strong> has to be done inside <code>dosync</code> in order to make transactional updates. Otherwise, Clojure complains with <code>No transaction running</code> exception.</p>
<h2 id='alter'>Alter</h2>
<p><code>alter</code> allows you to use a function to update the value of a ref.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">my-ref</span><span class="w"> </span><span class="p">(</span><span class="nb">ref</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span><span class="w">
</span><span class="o">#</span><span class="ss">'user/my-ref</span><span class="w">

</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">dosync</span><span class="w">
        </span><span class="p">(</span><span class="nb">alter</span><span class="w"> </span><span class="n">my-ref</span><span class="w">
        </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">current_ref</span><span class="p">]</span><span class="w">
            </span><span class="p">(</span><span class="nb">inc</span><span class="w"> </span><span class="n">current_ref</span><span class="p">))))</span><span class="w">
</span><span class="mi">1</span><span class="w">

</span><span class="n">user&gt;</span><span class="w"> </span><span class="err">@</span><span class="n">my-ref</span><span class="w">
</span><span class="mi">1</span><span class="w">

</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">dosync</span><span class="w">
        </span><span class="p">(</span><span class="nb">alter</span><span class="w"> </span><span class="n">my-ref</span><span class="w">
          </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">_</span><span class="p">]</span><span class="w"> </span><span class="s">"not int"</span><span class="p">)))</span><span class="w">
</span><span class="s">"not int"</span><span class="w">

</span><span class="n">user&gt;</span><span class="w"> </span><span class="err">@</span><span class="n">my-ref</span><span class="w">
</span><span class="s">"not int"</span><span class="w">
</span></code></pre>
<p><br>
<br>
<br></p>

<p>The function that you pass to <code>alter</code> will take an argument which is the current ref.</p>

<p><br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br></p>

<p>The ref is updated by the return value of the function.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">my-ref</span><span class="w"> </span><span class="p">(</span><span class="nb">ref</span><span class="w"> </span><span class="mi">100</span><span class="p">))</span><span class="w">
</span><span class="o">#</span><span class="ss">'user/atom-int</span><span class="w">

</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">multiple-by</span><span class="w">
        </span><span class="p">[</span><span class="n">current-ref</span><span class="w"> </span><span class="n">num</span><span class="p">]</span><span class="w">
        </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">current-ref</span><span class="w"> </span><span class="n">num</span><span class="p">))</span><span class="w">

</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">dosync</span><span class="w">
        </span><span class="p">(</span><span class="nb">alter</span><span class="w"> </span><span class="n">my-ref</span><span class="w"> </span><span class="n">multiple-by</span><span class="w"> </span><span class="mi">10</span><span class="p">))</span><span class="w">
</span><span class="mi">1000</span><span class="w">
</span></code></pre>
<p><br>
<br>
<br>
<br>
<br>
<br>
<br></p>

<p>You can pass a function that takes multiple arguments. The first argument of the function is the current atom.</p>
<h2 id='transaction'>Transaction</h2>
<p>This piece of code demonstrates how transaction works.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">user</span><span class="w"> </span><span class="p">(</span><span class="nb">ref</span><span class="w"> </span><span class="p">{}))</span><span class="w">
</span><span class="o">#</span><span class="ss">'user/user</span><span class="w">

</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">dosync</span><span class="w">
 </span><span class="p">(</span><span class="nb">alter</span><span class="w"> </span><span class="n">user</span><span class="w"> </span><span class="nb">merge</span><span class="w"> </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"Kim"</span><span class="p">})</span><span class="w">
 </span><span class="p">(</span><span class="nf">throw</span><span class="w"> </span><span class="p">(</span><span class="nf">Exception.</span><span class="w"> </span><span class="s">"something wrong happens!"</span><span class="p">))</span><span class="w">
 </span><span class="p">(</span><span class="nb">alter</span><span class="w"> </span><span class="n">user</span><span class="w"> </span><span class="nb">merge</span><span class="w"> </span><span class="p">{</span><span class="no">:age</span><span class="w"> </span><span class="mi">32</span><span class="p">}))</span><span class="w">
</span><span class="n">Exception</span><span class="w"> </span><span class="n">something</span><span class="w"> </span><span class="n">wrong</span><span class="w"> </span><span class="n">happens!</span><span class="w">  </span><span class="n">user/eval2997/fn--2998</span><span class="w"> </span><span class="p">(</span><span class="nf">NO_SOURCE_FILE</span><span class="no">:2</span><span class="p">)</span><span class="w">

</span><span class="n">user&gt;</span><span class="w"> </span><span class="err">@</span><span class="n">user</span><span class="w">
</span><span class="p">{}</span><span class="w">
</span></code></pre>
<p><br></p>

<p>Suppose we are trying to create an user record in database. Each <code>alter</code> tries to update user-record ref with user info and you want the ref to be updated only when both <code>alter</code> succeed.</p>

<p><br></p>

<p>But, let&#39;s assume something wrong occurs between the first and the second alter.</p>

<p><br>
<br></p>

<p>As you see, the user-record ref is still empty. This is because <code>alter</code> inside <code>dosync</code> doesn&#39;t update the ref until getting out of <code>dosync</code> block successfully.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">user-record</span><span class="w"> </span><span class="p">(</span><span class="nf">atom</span><span class="w"> </span><span class="p">{}))</span><span class="w">
</span><span class="o">#</span><span class="ss">'user/user-record</span><span class="w">

</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">do</span><span class="w">
 </span><span class="p">(</span><span class="nf">swap!</span><span class="w"> </span><span class="n">user-record</span><span class="w"> </span><span class="nb">merge</span><span class="w"> </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"Kim"</span><span class="p">})</span><span class="w">
 </span><span class="p">(</span><span class="nf">throw</span><span class="w"> </span><span class="p">(</span><span class="nf">Exception.</span><span class="w"> </span><span class="s">"something wrong happens!"</span><span class="p">))</span><span class="w">
 </span><span class="p">(</span><span class="nf">swap!</span><span class="w"> </span><span class="n">user-record</span><span class="w"> </span><span class="nb">merge</span><span class="w"> </span><span class="p">{</span><span class="no">:age</span><span class="w"> </span><span class="mi">32</span><span class="p">}))</span><span class="w">
</span><span class="n">Exception</span><span class="w"> </span><span class="n">something</span><span class="w"> </span><span class="n">wrong</span><span class="w"> </span><span class="n">happens!</span><span class="w">  </span><span class="n">user/eval3024</span><span class="w"> </span><span class="p">(</span><span class="nf">NO_SOURCE_FILE</span><span class="no">:3</span><span class="p">)</span><span class="w">

</span><span class="n">user&gt;</span><span class="w"> </span><span class="err">@</span><span class="n">user-record</span><span class="w">
</span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"Kim"</span><span class="p">}</span><span class="w">
</span></code></pre>
<p><br></p>

<p>This is the atom version that doesn&#39;t work. As you see, user-record atom is half updated when there is the exception.</p>
<pre class="highlight clojure tab-clojure"><code><span class="w">



</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">my-ref</span><span class="w"> </span><span class="p">(</span><span class="nb">ref</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span><span class="w">
</span><span class="o">#</span><span class="ss">'user/my-ref</span><span class="w">

</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">future</span><span class="w">
        </span><span class="p">(</span><span class="nb">dosync</span><span class="w">
          </span><span class="p">(</span><span class="nb">alter</span><span class="w"> </span><span class="n">my-ref</span><span class="w"> </span><span class="nb">inc</span><span class="p">)</span><span class="w">
          </span><span class="p">(</span><span class="nf">Thread/sleep</span><span class="w"> </span><span class="mi">5000</span><span class="p">)))</span><span class="w">
 </span><span class="o">#</span><span class="n">&lt;core$future_call$reify__6320</span><span class="err">@</span><span class="mi">6</span><span class="n">ef7be6a</span><span class="err">:</span><span class="w"> </span><span class="no">:pending&gt;</span><span class="w">

</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="err">@</span><span class="n">my-ref</span><span class="p">)</span><span class="w">
</span><span class="mi">0</span><span class="w">

</span><span class="c1">;; Wait 5 seconds</span><span class="w">
</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="err">@</span><span class="n">my-ref</span><span class="p">)</span><span class="w">
</span><span class="mi">1</span><span class="w">
</span></code></pre>
<p><br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br></p>

<p>The other way to see how transaction works is trying to observe the value of ref outside dosync block.</p>

<p><br>
<br>
<br></p>

<p>We use future to run the whole transaction in the separate thread and wait two seconds before exiting the dosync block.</p>

<p><br>
<br>
<br></p>

<p>The value of the ref is still 0 at this moment because the update to the ref is still not committed.</p>
<h1 id='java'>Java</h1>
<p>One of the great traits of Clojure is that you can use Java code from your Clojure code. This trait is called <strong>Java interop</strong>. Although Clojure has very rich standard libraries, sometimes you cannot find libraries that you need to solve your problems. If the library exists in Java, you can borrow it from your Clojure code.</p>
<h2 id='instantiation'>Instantiation</h2><pre class="highlight plaintext"><code>user&gt; (new java.util.Date)
#inst "2017-01-15T08:04:14.983-00:00"
</code></pre>
<p><br></p>

<p>You can create an instance with <code>new</code> which takes class name as first argument.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">new</span><span class="w"> </span><span class="n">java.util.Date</span><span class="w"> </span><span class="s">"2016/2/19"</span><span class="p">)</span><span class="w">
</span><span class="o">#</span><span class="n">inst</span><span class="w"> </span><span class="s">"2016-02-18T15:00:00.000-00:00"</span><span class="w">
</span></code></pre>
<p><br>
<br></p>

<p>The rest of arguments are passed to the constructor function.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">java.util.Date.</span><span class="p">)</span><span class="w">
</span><span class="o">#</span><span class="n">inst</span><span class="w"> </span><span class="s">"2017-01-15T08:17:02.580-00:00"</span><span class="w">

</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">java.util.Date.</span><span class="w"> </span><span class="s">"2016/2/19"</span><span class="p">)</span><span class="w">
</span><span class="o">#</span><span class="n">inst</span><span class="w"> </span><span class="s">"2016-02-18T15:00:00.000-00:00"</span><span class="w">
</span></code></pre>
<p><br>
<br></p>

<p>There is also <code>.</code> form available. <code>.</code> must be placed at the end of class name.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">current_date</span><span class="w"> </span><span class="p">(</span><span class="nb">new</span><span class="w"> </span><span class="n">java.util.Date</span><span class="p">)]</span><span class="w">
        </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="n">current_date</span><span class="p">))</span><span class="w">
</span><span class="o">#</span><span class="n">inst</span><span class="w"> </span><span class="s">"2017-01-15T13:02:29.613-00:00"</span><span class="w">
</span><span class="n">nil</span><span class="w">
</span></code></pre>
<p><br>
<br>
<br>
<br>
<br></p>

<p>You can also bind Java&#39;s instance just like Clojure&#39;s value.</p>
<h2 id='method-invocation'>Method invocation</h2>
<p>Clojure doesn&#39;t provide an exponential calculation function in the standard library, so let&#39;s borrow <code>pow</code> method from <code>Math</code> class.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">Math/pow</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w">
</span><span class="mf">8.0</span><span class="w">
</span></code></pre>
<p><br></p>

<p>You can call Java&#39;s method just like Clojure&#39;s function. Here is how to call <code>pow</code> class method of <code>Math</code> class. The class method invocation takes a form of <code>(Classname/Method)</code>.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">current_date</span><span class="w"> </span><span class="p">(</span><span class="nb">new</span><span class="w"> </span><span class="n">java.util.Date</span><span class="p">)]</span><span class="w">
        </span><span class="p">(</span><span class="nf">.toString</span><span class="w"> </span><span class="n">current_date</span><span class="p">))</span><span class="w">
</span><span class="s">"Sun Jan 15 21:44:06 JST 2017"</span><span class="w">
</span></code></pre>
<p><br></p>

<p>The instance method invocation takes a form of <code>(.MethodName Instance Args)</code>. This example is equivalent to <code>current_date.toString()</code> in Java.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">current_date</span><span class="w"> </span><span class="p">(</span><span class="nb">new</span><span class="w"> </span><span class="n">java.util.Date</span><span class="p">)]</span><span class="w">
        </span><span class="p">(</span><span class="nb">.</span><span class="w"> </span><span class="n">current_date</span><span class="w"> </span><span class="n">toString</span><span class="p">))</span><span class="w">
</span><span class="s">"Sun Jan 15 22:30:45 JST 2017"</span><span class="w">
</span></code></pre>
<p><br>
<br></p>

<p>There is also <code>.</code> form available.</p>
<pre class="highlight clojure tab-clojure"><code><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">date1</span><span class="w"> </span><span class="p">(</span><span class="nb">new</span><span class="w"> </span><span class="n">java.util.Date</span><span class="p">)</span><span class="w">
            </span><span class="n">date2</span><span class="w"> </span><span class="p">(</span><span class="nb">new</span><span class="w"> </span><span class="n">java.util.Date</span><span class="p">)]</span><span class="w">
        </span><span class="p">(</span><span class="nf">.equals</span><span class="w"> </span><span class="n">date1</span><span class="w"> </span><span class="n">date2</span><span class="p">))</span><span class="w">
</span><span class="n">true</span><span class="w">
</span></code></pre>
<p><br>
<br>
<br></p>

<p>If you want to call a method that takes arguments, you can pass them after an instance. This example is equivalent to <code>date1.equals(date2)</code> in Java.</p>
<h1 id='many-thanks'>Many Thanks</h1>
<p><a href="https://aphyr.com/tags/Clojure-from-the-ground-up">Clojure from the ground up</a></p>

<p><a href="http://www.braveclojure.com/">CLOJURE for the BRAVE and TRUE</a></p>

<p><a href="https://pragprog.com/titles/shcloj/programming-clojure">Programming Clojure</a></p>

<p><a href="http://clojure.org/cheatsheet">Clojure Cheatsheet</a></p>

<p>And many other great articles and pages made by the Clojure community.</p>

      </div>
      <div class="dark-box">
      </div>
    </div>
  </body>
</html>
